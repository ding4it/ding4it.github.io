<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>STL源码剖析（3） | Ding4it的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="dequedeque 是一种双向开口的“连续”线性空间，即可以在头尾两端分别做元素的插入和删除操作。
外部接口看起来是连续的，内部是多个内存块的组合。近似连续。
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364">
<meta property="og:type" content="article">
<meta property="og:title" content="STL源码剖析（3）">
<meta property="og:url" content="http://yoursite.com/2016/04/28/STL-3/index.html">
<meta property="og:site_name" content="Ding4it的博客">
<meta property="og:description" content="dequedeque 是一种双向开口的“连续”线性空间，即可以在头尾两端分别做元素的插入和删除操作。
外部接口看起来是连续的，内部是多个内存块的组合。近似连续。
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364">
<meta property="og:updated_time" content="2016-05-16T05:20:37.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="STL源码剖析（3）">
<meta name="twitter:description" content="dequedeque 是一种双向开口的“连续”线性空间，即可以在头尾两端分别做元素的插入和删除操作。
外部接口看起来是连续的，内部是多个内存块的组合。近似连续。
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364">
  
    <link rel="alternate" href="/atom.xml" title="Ding4it的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ding4it的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-STL-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/28/STL-3/" class="article-date">
  <time datetime="2016-04-28T09:39:49.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      STL源码剖析（3）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>deque 是一种双向开口的“连续”线性空间，即可以在头尾两端分别做元素的插入和删除操作。</p>
<p>外部接口看起来是连续的，内部是多个内存块的组合。近似连续。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Ref, <span class="keyword">class</span> _Ptr&gt;</span><br><span class="line"><span class="keyword">struct</span> _Deque_iterator &#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp, <span class="keyword">const</span> _Tp&amp;, <span class="keyword">const</span> _Tp*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> _S_buffer_size() &#123; return __deque_buf_size(sizeof(_Tp)); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rando access,可以随机访问</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp** _Map_pointer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator _Self;</span><br><span class="line">  <span class="comment">// 一个iterator包含一块缓冲区的信息</span></span><br><span class="line">  <span class="comment">// 指向当前内容</span></span><br><span class="line">  _Tp* _M_cur;</span><br><span class="line">  <span class="comment">// 该缓冲区头部</span></span><br><span class="line">  _Tp* _M_first;</span><br><span class="line">  <span class="comment">// 尾部</span></span><br><span class="line">  _Tp* _M_last;</span><br><span class="line">  <span class="comment">// 指向对应的总的map的节点指针</span></span><br><span class="line">  _Map_pointer _M_node;</span><br><span class="line"></span><br><span class="line">  _Deque_iterator(_Tp* __x, _Map_pointer __y) </span><br><span class="line">    : _M_cur(__x), _M_first(*__y),</span><br><span class="line">      _M_last(*__y + _S_buffer_size()), _M_node(__y) &#123;&#125;</span><br><span class="line">  _Deque_iterator() : _M_cur(<span class="number">0</span>), _M_first(<span class="number">0</span>), _M_last(<span class="number">0</span>), _M_node(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  _Deque_iterator(<span class="keyword">const</span> iterator&amp; __x)</span><br><span class="line">    : _M_cur(__x._M_cur), _M_first(__x._M_first), </span><br><span class="line">      _M_last(__x._M_last), _M_node(__x._M_node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; return *_M_cur; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; return _M_cur; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//随机访问，指针加减虽然不像vector那样方便，但也就简单的计算就可得出。</span></span><br><span class="line">  difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> _Self&amp; __x) <span class="keyword">const</span> &#123;</span><br><span class="line">    return difference_type(_S_buffer_size()) * (_M_node - __x._M_node - <span class="number">1</span>) +</span><br><span class="line">      (_M_cur - _M_first) + (__x._M_last - __x._M_cur);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    ++_M_cur;</span><br><span class="line">    <span class="keyword">if</span> (_M_cur == _M_last) &#123;</span><br><span class="line">      _M_set_node(_M_node + <span class="number">1</span>);</span><br><span class="line">      _M_cur = _M_first;</span><br><span class="line">    &#125;</span><br><span class="line">    return *<span class="keyword">this</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>++(<span class="keyword">int</span>)  &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    return __tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_cur == _M_first) &#123;</span><br><span class="line">      _M_set_node(_M_node - <span class="number">1</span>);</span><br><span class="line">      _M_cur = _M_last;</span><br><span class="line">    &#125;</span><br><span class="line">    --_M_cur;</span><br><span class="line">    return *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    return __tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>+=(difference_type __n)</span><br><span class="line">  &#123;</span><br><span class="line">    difference_type __offset = __n + (_M_cur - _M_first);</span><br><span class="line">    <span class="keyword">if</span> (__offset &gt;= <span class="number">0</span> &amp;&amp; __offset &lt; difference_type(_S_buffer_size()))</span><br><span class="line">      _M_cur += __n;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      difference_type __node_offset =</span><br><span class="line">        __offset &gt; <span class="number">0</span> ? __offset / difference_type(_S_buffer_size())</span><br><span class="line">                   : -difference_type((-__offset - <span class="number">1</span>) / _S_buffer_size()) - <span class="number">1</span>;</span><br><span class="line">      _M_set_node(_M_node + __node_offset);</span><br><span class="line">      _M_cur = _M_first + </span><br><span class="line">        (__offset - __node_offset * difference_type(_S_buffer_size()));</span><br><span class="line">    &#125;</span><br><span class="line">    return *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Self <span class="keyword">operator</span>+(difference_type __n) <span class="keyword">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    return __tmp += __n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>-=(difference_type __n) &#123; return *<span class="keyword">this</span> += -__n; &#125;</span><br><span class="line"> </span><br><span class="line">  _Self <span class="keyword">operator</span>-(difference_type __n) <span class="keyword">const</span> &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    return __tmp -= __n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 随机访问，返回reference形式，可做左值</span></span><br><span class="line">  reference <span class="keyword">operator</span>[](difference_type __n) <span class="keyword">const</span> &#123; return *(*this + __n); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(const _Self&amp; __x) <span class="keyword">const</span> &#123; return _M_cur == __x._M_cur; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(const _Self&amp; __x) <span class="keyword">const</span> &#123; return !(*this == __x); &#125;</span><br><span class="line">  <span class="comment">// 线比较node指针大小，node一样，则比较对应的cur指针</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> _Self&amp; __x) <span class="keyword">const</span> &#123;</span><br><span class="line">    return (_M_node == __x._M_node) ? </span><br><span class="line">      (_M_cur &lt; __x._M_cur) : (_M_node &lt; __x._M_node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> _Self&amp; __x) <span class="keyword">const</span>  &#123; return __x &lt; *<span class="keyword">this</span>; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(const _Self&amp; __x) <span class="keyword">const</span> &#123; return !(__x &lt; *this); &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(const _Self&amp; __x) <span class="keyword">const</span> &#123; return !(*this &lt; __x); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _M_set_node(_Map_pointer __new_node) &#123;</span><br><span class="line">    _M_node = __new_node;</span><br><span class="line">    _M_first = *__new_node;</span><br><span class="line">    _M_last = _M_first + difference_type(_S_buffer_size());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">class</span> _Deque_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp,_Tp&amp;,_Tp*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp,<span class="keyword">const</span> _Tp&amp;,<span class="keyword">const</span> _Tp*&gt; const_iterator;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> _Alloc allocator_type;</span><br><span class="line">  <span class="function">allocator_type <span class="title">get_allocator</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; return allocator_type(); &#125;</span><br><span class="line"></span><br><span class="line">  _Deque_base(<span class="keyword">const</span> allocator_type&amp;, <span class="keyword">size_t</span> __num_elements)</span><br><span class="line">    : _M_map(<span class="number">0</span>), _M_map_size(<span class="number">0</span>),  _M_start(), _M_finish() &#123;</span><br><span class="line">    _M_initialize_map(__num_elements);</span><br><span class="line">  &#125;</span><br><span class="line">  _Deque_base(<span class="keyword">const</span> allocator_type&amp;)</span><br><span class="line">    : _M_map(<span class="number">0</span>), _M_map_size(<span class="number">0</span>),  _M_start(), _M_finish() &#123;&#125;</span><br><span class="line">  ~_Deque_base();    </span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">void</span> _M_initialize_map(<span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">void</span> _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);</span><br><span class="line">  <span class="keyword">void</span> _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);</span><br><span class="line">  <span class="comment">// 默认的map大小为8快，当然，map节点对应的区域没有初始化，需要再初始化</span></span><br><span class="line">  <span class="keyword">enum</span> &#123; _S_initial_map_size = <span class="number">8</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  _Tp** _M_map;</span><br><span class="line">  <span class="keyword">size_t</span> _M_map_size;</span><br><span class="line">  <span class="comment">// 指向对应的缓冲区buffer</span></span><br><span class="line">  iterator _M_start;</span><br><span class="line">  iterator _M_finish;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;_Tp, _Alloc&gt;  _Node_alloc_type;</span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;_Tp*, _Alloc&gt; _Map_alloc_type;</span><br><span class="line"></span><br><span class="line">  _Tp* _M_allocate_node()</span><br><span class="line">    &#123; return _Node_alloc_type::allocate(__deque_buf_size(sizeof(_Tp))); &#125;</span><br><span class="line">  <span class="keyword">void</span> _M_deallocate_node(_Tp* __p)</span><br><span class="line">    &#123; _Node_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp))); &#125;</span><br><span class="line">  _Tp** _M_allocate_map(<span class="keyword">size_t</span> __n) </span><br><span class="line">    &#123; return _Map_alloc_type::allocate(__n); &#125;</span><br><span class="line">  <span class="keyword">void</span> _M_deallocate_map(_Tp** __p, <span class="keyword">size_t</span> __n) </span><br><span class="line">    &#123; _Map_alloc_type::deallocate(__p, __n); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// num_elements=0的时候，也会先分配一个缓冲区出来</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_Deque_base&lt;_Tp,_Alloc&gt;::_M_initialize_map(<span class="keyword">size_t</span> __num_elements)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">size_t</span> __num_nodes = </span><br><span class="line">    __num_elements / __deque_buf_size(sizeof(_Tp)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  _M_map_size = max((<span class="keyword">size_t</span>) _S_initial_map_size, __num_nodes + <span class="number">2</span>);</span><br><span class="line">  _M_map = _M_allocate_map(_M_map_size);</span><br><span class="line"></span><br><span class="line">  _Tp** __nstart = _M_map + (_M_map_size - __num_nodes) / <span class="number">2</span>;</span><br><span class="line">  _Tp** __nfinish = __nstart + __num_nodes;</span><br><span class="line">    </span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    _M_create_nodes(__nstart, __nfinish);</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND((_M_deallocate_map(_M_map, _M_map_size), </span><br><span class="line">                _M_map = <span class="number">0</span>, _M_map_size = <span class="number">0</span>));</span><br><span class="line">  _M_start._M_set_node(__nstart);</span><br><span class="line">  _M_finish._M_set_node(__nfinish - <span class="number">1</span>);</span><br><span class="line">  _M_start._M_cur = _M_start._M_first;</span><br><span class="line">  _M_finish._M_cur = _M_finish._M_first +</span><br><span class="line">               __num_elements % __deque_buf_size(sizeof(_Tp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class="line">class deque : protected _Deque_base&lt;_Tp, _Alloc&gt; &#123;</span><br><span class="line">public:                         // Constructor, destructor.</span><br><span class="line">  // 初始化_Base的时候都会带上大小。</span><br><span class="line">  explicit deque(const allocator_type&amp; __a = allocator_type()) </span><br><span class="line">    : _Base(__a, 0) &#123;&#125;</span><br><span class="line">  deque(const deque&amp; __x) : _Base(__x.get_allocator(), __x.size()) </span><br><span class="line">    &#123; uninitialized_copy(__x.begin(), __x.end(), _M_start); &#125;</span><br><span class="line">  deque(size_type __n, const value_type&amp; __value,</span><br><span class="line">        const allocator_type&amp; __a = allocator_type()) : _Base(__a, __n)</span><br><span class="line">    &#123; _M_fill_initialize(__value); &#125;</span><br><span class="line">  explicit deque(size_type __n) : _Base(allocator_type(), __n)</span><br><span class="line">    &#123; _M_fill_initialize(value_type()); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Alloc&gt;</span><br><span class="line">void deque&lt;_Tp,_Alloc&gt;::_M_reallocate_map(size_type __nodes_to_add,</span><br><span class="line">                                          bool __add_at_front)</span><br><span class="line">&#123;</span><br><span class="line">  size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + 1;</span><br><span class="line">  size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;</span><br><span class="line"></span><br><span class="line">  _Map_pointer __new_nstart;</span><br><span class="line">  // 如果map大小孩足够大，但是估计是左边或右边到头了，则不申请新的内存，直接copy换个位置就行。</span><br><span class="line">  if (_M_map_size &gt; 2 * __new_num_nodes) &#123;</span><br><span class="line">    __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / 2 </span><br><span class="line">                     + (__add_at_front ? __nodes_to_add : 0);</span><br><span class="line">    if (__new_nstart &lt; _M_start._M_node)</span><br><span class="line">      //一个是copy，从前往后复制</span><br><span class="line">      copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);</span><br><span class="line">    else</span><br><span class="line">      // 一个是copy_backward，从后往前复制</span><br><span class="line">      copy_backward(_M_start._M_node, _M_finish._M_node + 1, </span><br><span class="line">                    __new_nstart + __old_num_nodes);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    //否则，申请新的内存区域了</span><br><span class="line">    size_type __new_map_size = </span><br><span class="line">      _M_map_size + max(_M_map_size, __nodes_to_add) + 2;</span><br><span class="line"></span><br><span class="line">    _Map_pointer __new_map = _M_allocate_map(__new_map_size);</span><br><span class="line">    __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2</span><br><span class="line">                         + (__add_at_front ? __nodes_to_add : 0);</span><br><span class="line">    copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);</span><br><span class="line">    _M_deallocate_map(_M_map, _M_map_size);</span><br><span class="line"></span><br><span class="line">    _M_map = __new_map;</span><br><span class="line">    _M_map_size = __new_map_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _M_start._M_set_node(__new_nstart);</span><br><span class="line">  _M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);</span><br><span class="line">&#125;</span><br><span class="line">//deque比较相等，是比较内部的数据是否相等。其他容器vector,list应该也相应重载了。</span><br><span class="line">template &lt;class _Tp, class _Alloc&gt;</span><br><span class="line">inline bool operator==(const deque&lt;_Tp, _Alloc&gt;&amp; __x,</span><br><span class="line">                       const deque&lt;_Tp, _Alloc&gt;&amp; __y) &#123;</span><br><span class="line">  return __x.size() == __y.size() &amp;&amp;</span><br><span class="line">         equal(__x.begin(), __x.end(), __y.begin());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，deque的<code>erase(), insert()</code>除非在头尾，不然都算O(n)的复杂度，因为要移动其他数据。连续内存块没办法。像List的话，只要有插入或移除的对应的iterator，就是O(1)的复杂度，不过一般要得到这个iterator也得O(n)的复杂度来寻找。</p>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>stack只是普通的容器对接口做了些限制。SGI STL 以deque作为缺省情况下的stack底部结构。stack代码也真是短。接口也少。无法遍历。有一个底部容器的话，分分钟写一个stack。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#ifndef __SGI_STL_INTERNAL_STACK_H</span><br><span class="line">#define __SGI_STL_INTERNAL_STACK_H</span><br><span class="line"></span><br><span class="line">#include &lt;sequence_concepts.h&gt;</span><br><span class="line"></span><br><span class="line">__STL_BEGIN_NAMESPACE</span><br><span class="line"></span><br><span class="line">// Forward declarations of operators == and &lt;, needed for friend declaration.</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, </span><br><span class="line">          class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(deque&lt;_Tp&gt;) &gt;</span><br><span class="line">class stack;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator==(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y);</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator&lt;(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Sequence&gt;</span><br><span class="line">class stack &#123;</span><br><span class="line"></span><br><span class="line">  // requirements:</span><br><span class="line"></span><br><span class="line">  __STL_CLASS_REQUIRES(_Tp, _Assignable);</span><br><span class="line">  __STL_CLASS_REQUIRES(_Sequence, _BackInsertionSequence);</span><br><span class="line">  typedef typename _Sequence::value_type _Sequence_value_type;</span><br><span class="line">  __STL_CLASS_REQUIRES_SAME_TYPE(_Tp, _Sequence_value_type);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef __STL_MEMBER_TEMPLATES</span><br><span class="line">  template &lt;class _Tp1, class _Seq1&gt;</span><br><span class="line">  friend bool operator== (const stack&lt;_Tp1, _Seq1&gt;&amp;,</span><br><span class="line">                          const stack&lt;_Tp1, _Seq1&gt;&amp;);</span><br><span class="line">  template &lt;class _Tp1, class _Seq1&gt;</span><br><span class="line">  friend bool operator&lt; (const stack&lt;_Tp1, _Seq1&gt;&amp;,</span><br><span class="line">                         const stack&lt;_Tp1, _Seq1&gt;&amp;);</span><br><span class="line">#else /* __STL_MEMBER_TEMPLATES */</span><br><span class="line">  friend bool __STD_QUALIFIER</span><br><span class="line">  operator== __STL_NULL_TMPL_ARGS (const stack&amp;, const stack&amp;);</span><br><span class="line">  friend bool __STD_QUALIFIER</span><br><span class="line">  operator&lt; __STL_NULL_TMPL_ARGS (const stack&amp;, const stack&amp;);</span><br><span class="line">#endif /* __STL_MEMBER_TEMPLATES */</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  typedef typename _Sequence::value_type      value_type;</span><br><span class="line">  typedef typename _Sequence::size_type       size_type;</span><br><span class="line">  typedef          _Sequence                  container_type;</span><br><span class="line"></span><br><span class="line">  typedef typename _Sequence::reference       reference;</span><br><span class="line">  typedef typename _Sequence::const_reference const_reference;</span><br><span class="line">protected:</span><br><span class="line">  _Sequence c;</span><br><span class="line">public:</span><br><span class="line">  stack() : c() &#123;&#125;</span><br><span class="line">  explicit stack(const _Sequence&amp; __s) : c(__s) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  bool empty() const &#123; return c.empty(); &#125;</span><br><span class="line">  size_type size() const &#123; return c.size(); &#125;</span><br><span class="line">  reference top() &#123; return c.back(); &#125;</span><br><span class="line">  const_reference top() const &#123; return c.back(); &#125;</span><br><span class="line">  void push(const value_type&amp; __x) &#123; c.push_back(__x); &#125;</span><br><span class="line">  void pop() &#123; c.pop_back(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">//对应容器是否相等</span><br><span class="line">bool operator==(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return __x.c == __y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator&lt;(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return __x.c &lt; __y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator!=(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return !(__x == __y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator&gt;(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return __y &lt; __x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator&lt;=(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return !(__y &lt; __x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator&gt;=(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return !(__x &lt; __y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */</span><br><span class="line"></span><br><span class="line">__STL_END_NAMESPACE</span><br><span class="line"></span><br><span class="line">#endif /* __SGI_STL_INTERNAL_STACK_H */</span><br></pre></td></tr></table></figure>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>queue是一种先进先出（FIFO）的数据结构。从底部加入元素，从顶部取出元素。不允许遍历。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//默认用deque做底部容器</span><br><span class="line">template &lt;class _Tp, </span><br><span class="line">          class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(deque&lt;_Tp&gt;) &gt;</span><br><span class="line">class queue;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Sequence&gt;</span><br><span class="line">class queue &#123;</span><br><span class="line"></span><br><span class="line">  // requirements:</span><br><span class="line"></span><br><span class="line">  __STL_CLASS_REQUIRES(_Tp, _Assignable);</span><br><span class="line">  __STL_CLASS_REQUIRES(_Sequence, _FrontInsertionSequence);</span><br><span class="line">  __STL_CLASS_REQUIRES(_Sequence, _BackInsertionSequence);</span><br><span class="line">  typedef typename _Sequence::value_type _Sequence_value_type;</span><br><span class="line">  __STL_CLASS_REQUIRES_SAME_TYPE(_Tp, _Sequence_value_type);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef __STL_MEMBER_TEMPLATES </span><br><span class="line">  template &lt;class _Tp1, class _Seq1&gt;</span><br><span class="line">  friend bool operator== (const queue&lt;_Tp1, _Seq1&gt;&amp;,</span><br><span class="line">                          const queue&lt;_Tp1, _Seq1&gt;&amp;);</span><br><span class="line">  template &lt;class _Tp1, class _Seq1&gt;</span><br><span class="line">  friend bool operator&lt; (const queue&lt;_Tp1, _Seq1&gt;&amp;,</span><br><span class="line">                         const queue&lt;_Tp1, _Seq1&gt;&amp;);</span><br><span class="line">#else /* __STL_MEMBER_TEMPLATES */</span><br><span class="line">  //对应的容器是否相同(重载过==操作)。</span><br><span class="line">  friend bool __STD_QUALIFIER</span><br><span class="line">  operator== __STL_NULL_TMPL_ARGS (const queue&amp;, const queue&amp;);</span><br><span class="line">  friend bool __STD_QUALIFIER</span><br><span class="line">  operator&lt;  __STL_NULL_TMPL_ARGS (const queue&amp;, const queue&amp;);</span><br><span class="line">#endif /* __STL_MEMBER_TEMPLATES */</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  typedef typename _Sequence::value_type      value_type;</span><br><span class="line">  typedef typename _Sequence::size_type       size_type;</span><br><span class="line">  typedef          _Sequence                  container_type;</span><br><span class="line"></span><br><span class="line">  typedef typename _Sequence::reference       reference;</span><br><span class="line">  typedef typename _Sequence::const_reference const_reference;</span><br><span class="line">protected:</span><br><span class="line">  _Sequence c;</span><br><span class="line">public:</span><br><span class="line">  //对外只有这几个接口。front, back, push, pop</span><br><span class="line">  queue() : c() &#123;&#125;</span><br><span class="line">  explicit queue(const _Sequence&amp; __c) : c(__c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  bool empty() const &#123; return c.empty(); &#125;</span><br><span class="line">  size_type size() const &#123; return c.size(); &#125;</span><br><span class="line">  reference front() &#123; return c.front(); &#125;</span><br><span class="line">  const_reference front() const &#123; return c.front(); &#125;</span><br><span class="line">  reference back() &#123; return c.back(); &#125;</span><br><span class="line">  const_reference back() const &#123; return c.back(); &#125;</span><br><span class="line">  void push(const value_type&amp; __x) &#123; c.push_back(__x); &#125;</span><br><span class="line">  void pop() &#123; c.pop_front(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p>heap是对应的一些堆算法，不指定特殊容器。priority_queue用其进行实现和维护。底部还是需要其他容器支持。</p>
<p>警告：堆排序是不稳定的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//push_heap 对应的代码结构，从底部往上找，知道找到该点，其parent的value大于该value</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Distance, <span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__push_heap(_RandomAccessIterator __first,</span><br><span class="line">            _Distance __holeIndex, _Distance __topIndex, _Tp __value)</span><br><span class="line">&#123;</span><br><span class="line">  _Distance __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (__holeIndex &gt; __topIndex &amp;&amp; *(__first + __parent) &lt; __value) &#123;</span><br><span class="line">    <span class="comment">//将value下移至子节点</span></span><br><span class="line">    *(__first + __holeIndex) = *(__first + __parent);</span><br><span class="line">    __holeIndex = __parent;</span><br><span class="line">    __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  &#125;    </span><br><span class="line">  *(__first + __holeIndex) = __value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Distance, <span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">__push_heap_aux(_RandomAccessIterator __first,</span><br><span class="line">                _RandomAccessIterator __last, _Distance*, _Tp*)</span><br><span class="line">&#123;</span><br><span class="line">  __push_heap(__first, _Distance((__last - __first) - <span class="number">1</span>), _Distance(<span class="number">0</span>), </span><br><span class="line">              _Tp(*(__last - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line"><span class="title">push_heap</span><span class="params">(_RandomAccessIterator __first, _RandomAccessIterator __last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __push_heap_aux(__first, __last,</span><br><span class="line">                  __DISTANCE_TYPE(__first), __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pop_heap对应的代码</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Distance, <span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,</span><br><span class="line">              _Distance __len, _Tp __value)</span><br><span class="line">&#123;</span><br><span class="line">  _Distance __topIndex = __holeIndex;</span><br><span class="line">  _Distance __secondChild = <span class="number">2</span> * __holeIndex + <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//先不断往下走走走，走到叶子节点。将左右子节点较大值放入parent，然后转到该较大子节点处。循环。</span></span><br><span class="line">  <span class="keyword">while</span> (__secondChild &lt; __len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*(__first + __secondChild) &lt; *(__first + (__secondChild - <span class="number">1</span>)))</span><br><span class="line">      __secondChild--;</span><br><span class="line">    *(__first + __holeIndex) = *(__first + __secondChild);</span><br><span class="line">    __holeIndex = __secondChild;</span><br><span class="line">    __secondChild = <span class="number">2</span> * (__secondChild + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (__secondChild == __len) &#123;</span><br><span class="line">    *(__first + __holeIndex) = *(__first + (__secondChild - <span class="number">1</span>));</span><br><span class="line">    __holeIndex = __secondChild - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//然后在往上push_heap,把value插进去！目前该叶节点是没有内容的。</span></span><br><span class="line">  __push_heap(__first, __holeIndex, __topIndex, __value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Distance&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">           _RandomAccessIterator __result, _Tp __value, _Distance*)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//先把最大值移到末尾处</span></span><br><span class="line">  *__result = *__first;</span><br><span class="line">  <span class="comment">//然后调整heap，插入原本处在末尾的value</span></span><br><span class="line">  __adjust_heap(__first, _Distance(<span class="number">0</span>), _Distance(__last - __first), __value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">__pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">               _Tp*)</span><br><span class="line">&#123;</span><br><span class="line">  __pop_heap(__first, __last - <span class="number">1</span>, __last - <span class="number">1</span>, </span><br><span class="line">             _Tp(*(__last - <span class="number">1</span>)), __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(_RandomAccessIterator __first, </span><br><span class="line">                     _RandomAccessIterator __last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __pop_heap_aux(__first, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不明白为什么pop_heap的时候要先下移至叶节点，然后在进行push_heap。明明直接从上往下的时候就判断什么时候停止然后放入目标value。虽然他们的复杂度一样O(n)，但是差了一倍吧。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sort_heap首先要保证first到last的数据结构是一个合法的heap，然后不断pop最大值到尾部，实现sort</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(_RandomAccessIterator __first, _RandomAccessIterator __last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; <span class="number">1</span>)</span><br><span class="line">    pop_heap(__first, __last--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Distance&gt;</span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__make_heap(_RandomAccessIterator __first,</span><br><span class="line">            _RandomAccessIterator __last, _Tp*, _Distance*)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__last - __first &lt; <span class="number">2</span>) return;</span><br><span class="line">  _Distance __len = __last - __first;</span><br><span class="line">  <span class="comment">//从节点的一半处开始，heap是一个完全二叉树，叶节点从左到右是满的，不会终结空一个出来。</span></span><br><span class="line">  <span class="comment">//也就是这个parent现在没有或刚有子节点（一个2或3个节点的小树）。</span></span><br><span class="line">  _Distance __parent = (__len - <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//就first是iterator类型，parent是distance类型，调整以parent为根的子树。</span></span><br><span class="line">    <span class="comment">//然后parent--,不断增大子树范围，最终实现一个heap</span></span><br><span class="line">    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)));</span><br><span class="line">    <span class="keyword">if</span> (__parent == <span class="number">0</span>) return;</span><br><span class="line">    __parent--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line"><span class="title">make_heap</span><span class="params">(_RandomAccessIterator __first, _RandomAccessIterator __last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __make_heap(__first, __last,</span><br><span class="line">              __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p>优先队列。默认的compare是最大堆。然后底层容器sort()后就是升序。</p>
<p>默认以vector为底部容器。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class _Tp, </span><br><span class="line">          class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(vector&lt;_Tp&gt;),</span><br><span class="line">          class _Compare</span><br><span class="line">            //默认的compare是less</span><br><span class="line">          __STL_DEPENDENT_DEFAULT_TMPL(less&lt;typename _Sequence::value_type&gt;) &gt;</span><br><span class="line">class priority_queue &#123;</span><br><span class="line"> </span><br><span class="line">protected:</span><br><span class="line">  //一个底部容器，一个compare</span><br><span class="line">  _Sequence c;</span><br><span class="line">  _Compare comp;</span><br><span class="line">public:</span><br><span class="line">  priority_queue() : c() &#123;&#125;</span><br><span class="line">  explicit priority_queue(const _Compare&amp; __x) :  c(), comp(__x) &#123;&#125;</span><br><span class="line">  priority_queue(const _Compare&amp; __x, const _Sequence&amp; __s) </span><br><span class="line">    : c(__s), comp(__x) </span><br><span class="line">    &#123; make_heap(c.begin(), c.end(), comp); &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;class _InputIterator&gt;</span><br><span class="line">  priority_queue(_InputIterator __first, _InputIterator __last) </span><br><span class="line">    : c(__first, __last) &#123; make_heap(c.begin(), c.end(), comp); &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;class _InputIterator&gt;</span><br><span class="line">  priority_queue(_InputIterator __first, </span><br><span class="line">                 _InputIterator __last, const _Compare&amp; __x)</span><br><span class="line">    : c(__first, __last), comp(__x) </span><br><span class="line">    &#123; make_heap(c.begin(), c.end(), comp); &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;class _InputIterator&gt;</span><br><span class="line">  priority_queue(_InputIterator __first, _InputIterator __last,</span><br><span class="line">                 const _Compare&amp; __x, const _Sequence&amp; __s)</span><br><span class="line">  : c(__s), comp(__x)</span><br><span class="line">  &#123; </span><br><span class="line">    c.insert(c.end(), __first, __last);</span><br><span class="line">    make_heap(c.begin(), c.end(), comp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool empty() const &#123; return c.empty(); &#125;</span><br><span class="line">  size_type size() const &#123; return c.size(); &#125;</span><br><span class="line">  const_reference top() const &#123; return c.front(); &#125;</span><br><span class="line">  void push(const value_type&amp; __x) &#123;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      c.push_back(__x); //先把数据push_back到尾部，再调整堆。</span><br><span class="line">      push_heap(c.begin(), c.end(), comp);</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(c.clear());</span><br><span class="line">  &#125;</span><br><span class="line">  void pop() &#123;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      pop_heap(c.begin(), c.end(), comp);//先pop_heap</span><br><span class="line">      c.pop_back();再pop出尾部数据</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(c.clear());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="slist"><a href="#slist" class="headerlink" title="slist"></a>slist</h2><p>SGI STL提供的单向链表（single linked list）。不在标准规格之内。</p>
<p>由于是单向链表，所以只能在iterator之后插入、移除才是高效的。</p>
<p>slist特别提供了<code>insert_after(),erase_after()</code>供使用。同时，只提供<code>push_front()</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _Slist_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//指针</span></span><br><span class="line">  _Slist_node_base* _M_next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> _Slist_node : <span class="keyword">public</span> _Slist_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//具体数据</span></span><br><span class="line">  _Tp _M_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _Slist_iterator_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span>               size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>            difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> forward_iterator_tag iterator_category;</span><br><span class="line"></span><br><span class="line">  _Slist_node_base* _M_node;</span><br><span class="line"></span><br><span class="line">  _Slist_iterator_base(_Slist_node_base* __x) : _M_node(__x) &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> _M_incr() &#123; _M_node = _M_node-&gt;_M_next; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(const _Slist_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</span><br><span class="line">    return _M_node == __x._M_node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(const _Slist_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</span><br><span class="line">    return _M_node != __x._M_node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Ref, <span class="keyword">class</span> _Ptr&gt;</span><br><span class="line"><span class="keyword">struct</span> _Slist_iterator : <span class="keyword">public</span> _Slist_iterator_base</span><br><span class="line">&#123;</span><br><span class="line">  _Slist_iterator(_Node* __x) : _Slist_iterator_base(__x) &#123;&#125;</span><br><span class="line">  _Slist_iterator() : _Slist_iterator_base(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  _Slist_iterator(<span class="keyword">const</span> iterator&amp; __x) : _Slist_iterator_base(__x._M_node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; return ((_Node*) _M_node)-&gt;_M_data; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; return &amp;(operator*()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">  &#123;</span><br><span class="line">    _M_incr();</span><br><span class="line">    return *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    _M_incr();</span><br><span class="line">    return __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Alloc&gt; </span><br><span class="line"><span class="keyword">struct</span> _Slist_base &#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Alloc allocator_type;</span><br><span class="line">  <span class="function">allocator_type <span class="title">get_allocator</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; return allocator_type(); &#125;</span><br><span class="line"></span><br><span class="line">  _Slist_base(<span class="keyword">const</span> allocator_type&amp;) &#123; _M_head._M_next = <span class="number">0</span>; &#125;</span><br><span class="line">  ~_Slist_base() &#123; _M_erase_after(&amp;_M_head, <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;_Slist_node&lt;_Tp&gt;, _Alloc&gt; _Alloc_type;</span><br><span class="line">  _Slist_node&lt;_Tp&gt;* _M_get_node() &#123; return _Alloc_type::allocate(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="keyword">void</span> _M_put_node(_Slist_node&lt;_Tp&gt;* __p) &#123; _Alloc_type::deallocate(__p, <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  _Slist_node_base* _M_erase_after(_Slist_node_base* __pos)</span><br><span class="line">  &#123;</span><br><span class="line">    _Slist_node&lt;_Tp&gt;* __next = (_Slist_node&lt;_Tp&gt;*) (__pos-&gt;_M_next);</span><br><span class="line">    _Slist_node_base* __next_next = __next-&gt;_M_next;</span><br><span class="line">    __pos-&gt;_M_next = __next_next;</span><br><span class="line">    destroy(&amp;__next-&gt;_M_data);</span><br><span class="line">    _M_put_node(__next);</span><br><span class="line">    return __next_next;</span><br><span class="line">  &#125;</span><br><span class="line">  _Slist_node_base* _M_erase_after(_Slist_node_base*, _Slist_node_base*);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">//空的node当head</span></span><br><span class="line">  _Slist_node_base _M_head;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class="line"><span class="keyword">class</span> slist : <span class="keyword">private</span> _Slist_base&lt;_Tp,_Alloc&gt;&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也不在意多一个prev的指针，一般还是用list的好。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/28/STL-3/" data-id="cionug3mc000369nqaq1hqdnd" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-STL/">C++ STL</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/05/02/union-find/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          并查集union-find
        
      </div>
    </a>
  
  
    <a href="/2016/04/19/STL-2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">STL源码剖析（2）</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-STL/">C++ STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图-路径压缩/">图 路径压缩</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-STL/" style="font-size: 20px;">C++ STL</a> <a href="/tags/图-路径压缩/" style="font-size: 10px;">图 路径压缩</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/05/23/STL-7/">STL源码剖析（7）</a>
          </li>
        
          <li>
            <a href="/2016/05/20/STL-6/">STL源码剖析（6）</a>
          </li>
        
          <li>
            <a href="/2016/05/18/STL-5/">STL源码剖析（5）</a>
          </li>
        
          <li>
            <a href="/2016/05/16/STL-4/">STL源码剖析（4）</a>
          </li>
        
          <li>
            <a href="/2016/05/02/union-find/">并查集union-find</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 ding4it<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>