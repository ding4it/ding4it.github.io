<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Ding4it的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Nothing">
<meta property="og:type" content="website">
<meta property="og:title" content="Ding4it的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Ding4it的博客">
<meta property="og:description" content="Nothing">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ding4it的博客">
<meta name="twitter:description" content="Nothing">
  
    <link rel="alternate" href="/atom.xml" title="Ding4it的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ding4it的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-formula" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/20/formula/" class="article-date">
  <time datetime="2016-05-20T15:26:26.000Z" itemprop="datePublished">2016-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/20/formula/">formula</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>$$H<em>i-H</em>{i-1}=i^2-(i-1)^2 (mod M)$$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/20/formula/" data-id="ciofwrhct000621nqayzh22rg" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-STL-6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/20/STL-6/" class="article-date">
  <time datetime="2016-05-20T13:25:53.000Z" itemprop="datePublished">2016-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/20/STL-6/">STL源码剖析（6）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>Set的元素的键值就是实值，实值就是键值。且set不允许有两个元素相同的键值。</p>
<p>set的Iterator被定义为底层的const iterator，所以set的iterator只能读不能写。</p>
<p>set拥有与list相同的某些性质：当客户对他进行元素新增操作（insert）和删除操作（erase）时，操作之前的所有迭代器，在操作完之后都依然有效。</p>
<p>此外，针对set和multiset，STL特别提供了一组相关算法，包括交集（set_intersection）、并集（set_union）、差集（set_difference）、对称差集（set_symmetric_difference）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Key, <span class="keyword">class</span> _Compare, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">set</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//set的key_type和value_type都是Key类型。</span></span><br><span class="line">  <span class="keyword">typedef</span> _Key     key_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Key     value_type;</span><br><span class="line"><span class="comment">//对应一样的compare</span></span><br><span class="line">  <span class="keyword">typedef</span> _Compare key_compare;</span><br><span class="line">  <span class="keyword">typedef</span> _Compare value_compare;</span><br><span class="line">  <span class="comment">//然后定义Rep_type，</span></span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree&lt;key_type, value_type, </span><br><span class="line">                  _Identity&lt;value_type&gt;, key_compare, _Alloc&gt; _Rep_type；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看_Rb_tree的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Key, <span class="keyword">class</span> _Value, <span class="keyword">class</span> _KeyOfValue, <span class="keyword">class</span> _Compare,</span><br><span class="line">          <span class="keyword">class</span> _Alloc = __STL_DEFAULT_ALLOCATOR(_Value) &gt;</span><br><span class="line"><span class="keyword">class</span> _Rb_tree : <span class="keyword">protected</span> _Rb_tree_base&lt;_Value, _Alloc&gt;&#123;&#125;；</span><br></pre></td></tr></table></figure>
<p>可以看出<code>_KeyOfValue</code>实际对应的是<code>_Identity&lt;value_type&gt;</code>，这是通过value来获得key的程序，类里面获得key就是通过这个来得到的。</p>
<p>set的<code>_KeyOfValue</code>是一个<code>_Identity&lt;value_type&gt;</code>，<code>_KeyOfValue</code>就是实际的<code>value_type</code>。</p>
<p>对应的map的<code>_KeyOfValue</code>的是<code>_Select1st&lt;value_type&gt;</code>，因为在map里面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> _Key, _Tp&gt; value_type;</span><br></pre></td></tr></table></figure>
<p>map的value_type是一个<code>pair&lt;const _Key, _Tp&gt;</code>,然后<code>_Select1st&lt;value_type&gt;</code>就是得到的pair的第一个元素，即Key。</p>
<p>然后set也没啥了。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map的话，所有元素会根据元素的键值自动排序，内部肯定还是用红黑树的。</p>
<p>map的元素是一个pair，同事拥有实值和键值。pair的第一个元素是键值，第二个元素是实值。</p>
<p>看完红黑树，map和set已经没什么好看的了，就是一个容器。</p>
<h3 id="multiset-and-multimap"><a href="#multiset-and-multimap" class="headerlink" title="multiset and multimap"></a>multiset and multimap</h3><p>multiset 和 multimap 的话。之前的map和set的insert是<code>insert_unique()</code>。现在改成了<code>insert_equal()</code>。</p>
<h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><p>二叉搜索树是对数平均时间。然后hash table 散列表 在插入、删除、搜索等操作上具有常数平均时间的表现，且这种表现以统计为基础，不依赖于输入元素的随机性。</p>
<p>但是hash function 会有一个问题：可能不同的元素会被映射到相同的位置上。这就是所谓的“碰撞（collision）”问题。解决的办法有很多种，包括线性探测（linear probing）、二次探测（quadratic probing）、开链（separate chaining）等做法。</p>
<p>负载系数（loading factor）= 元素个数 / 表格大小</p>
<p>负载系数在0到1之间，除非采用开链策略。</p>
<h4 id="线性探测（linear-probing）"><a href="#线性探测（linear-probing）" class="headerlink" title="线性探测（linear probing）"></a>线性探测（linear probing）</h4><p>当hash function 计算出某个元素的插入位置，但是这个位置上的空间已经被占用时，应该怎么办？最简单的办法就是循序往下一一寻找空的空间，直到找到可用空间为止。在搜索元素是否存在时，也要意义寻找，直到找到吻合者，或者直到空的空间，说明元素不存在。</p>
<p>而在删除元素时，则必须采用惰性删除（lazy deletion），即只标记删除记号，并不真正删除，真正删除在下一次表格重新整理时执行。</p>
<p>有两个概念，<strong>主集团</strong> 和 <strong>次集团</strong>。连续的被占用的区域看做主集团。</p>
<h4 id="二次探测（quadratic-probing）"><a href="#二次探测（quadratic-probing）" class="headerlink" title="二次探测（quadratic probing）"></a>二次探测（quadratic probing）</h4><p>二次探测可以避免主集团，但是无法避免次集团。</p>
<p>很多元素hash出来的位置相同时，则形成次集团。</p>
<p>二次索引在面对碰撞时，不是采用+1的策略，而是采用方程$F[i] = i^2$这种形式。比如计算出来的位置是H，那么一次尝试的位置为$H+1^2,H+2^2,H+3^2，…，H+i^2$。可有效避免主集团。</p>
<p>然后呢。<br>$$H_i=H_0+1^2 (mod M)$$</p>
<p>$$H_{i-1}=H_0+(i-1)^2 (mode M)$$</p>
<p>$$H<em>i-H</em>{i-1}=i^2-(i-1)^2 (mod M)$$<br>这样就不用计算平方，就可以计算第$ i $个位置了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/20/STL-6/" data-id="ciofwrhcr000321nq02q0p7mc" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-STL/">C++ STL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-STL-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/18/STL-5/" class="article-date">
  <time datetime="2016-05-18T09:31:25.000Z" itemprop="datePublished">2016-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/18/STL-5/">STL源码剖析（5）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先定义了红黑二色</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">bool</span> _Rb_tree_Color_type;</span><br><span class="line"><span class="keyword">const</span> _Rb_tree_Color_type _S_rb_tree_red = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> _Rb_tree_Color_type _S_rb_tree_black = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//红黑树节点基础 struct</span></span><br><span class="line"><span class="keyword">struct</span> _Rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_Color_type _Color_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_node_base* _Base_ptr;</span><br><span class="line"></span><br><span class="line">  _Color_type _M_color; <span class="comment">//颜色</span></span><br><span class="line">  _Base_ptr _M_parent; <span class="comment">//父节点</span></span><br><span class="line">  _Base_ptr _M_left; <span class="comment">//左子节点</span></span><br><span class="line">  _Base_ptr _M_right; <span class="comment">//右子节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//最左叶节点最小</span></span><br><span class="line">  <span class="keyword">static</span> _Base_ptr _S_minimum(_Base_ptr __x)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> (__x-&gt;_M_left != <span class="number">0</span>) __x = __x-&gt;_M_left;</span><br><span class="line">    return __x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//最右叶节点最大</span></span><br><span class="line">  <span class="keyword">static</span> _Base_ptr _S_maximum(_Base_ptr __x)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> (__x-&gt;_M_right != <span class="number">0</span>) __x = __x-&gt;_M_right;</span><br><span class="line">    return __x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//继承了 base</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Value&gt;</span><br><span class="line"><span class="keyword">struct</span> _Rb_tree_node : <span class="keyword">public</span> _Rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_node&lt;_Value&gt;* _Link_type;</span><br><span class="line">  _Value _M_value_field; <span class="comment">//就多了一个value属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator base 跟  node base 是一起的</span></span><br><span class="line"><span class="keyword">struct</span> _Rb_tree_base_iterator</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_node_base::_Base_ptr _Base_ptr;</span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  _Base_ptr _M_node;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//右子节点的最左叶节点</span></span><br><span class="line">  <span class="keyword">void</span> _M_increment()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_node-&gt;_M_right != <span class="number">0</span>) &#123;</span><br><span class="line">      _M_node = _M_node-&gt;_M_right;</span><br><span class="line">      <span class="keyword">while</span> (_M_node-&gt;_M_left != <span class="number">0</span>)</span><br><span class="line">        _M_node = _M_node-&gt;_M_left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果该节点没有右节点了，就找其父节点，知道该节点是他父父……节点的左边节点，然后返回该父父父……节点。</span></span><br><span class="line">      _Base_ptr __y = _M_node-&gt;_M_parent;</span><br><span class="line">      <span class="keyword">while</span> (_M_node == __y-&gt;_M_right) &#123;</span><br><span class="line">        _M_node = __y;</span><br><span class="line">        __y = __y-&gt;_M_parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*这里是实现上有个header节点，</span><br><span class="line">       header 的父节点是root，root的父节点是header。</span><br><span class="line">       如果他已经是最右节点了，没有++了，那么现在y就是header，node就是root</span><br><span class="line">       然后_M_node-&gt;_M_right != __y的话，node就是y=header了。</span><br><span class="line">      _M_node-&gt;_M_right == __y的情况是当前节点是root，且他没有右节点，然后node = root, y = header,y的right是最右节点，现在就是root,然后满足上面的while ，++ 后，node是header,y是root，不满足while了，但是我们要返回header，就是node，所以不用下面的if内的一句了。</span><br><span class="line">      */</span></span><br><span class="line">      <span class="keyword">if</span> (_M_node-&gt;_M_right != __y)</span><br><span class="line">        _M_node = __y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _M_decrement()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 当node是header的时候，会走到该if，然后node=最右节点</span></span><br><span class="line">    <span class="comment">// header为红色，root为黑色</span></span><br><span class="line">    <span class="keyword">if</span> (_M_node-&gt;_M_color == _S_rb_tree_red &amp;&amp;</span><br><span class="line">        _M_node-&gt;_M_parent-&gt;_M_parent == _M_node)</span><br><span class="line">      _M_node = _M_node-&gt;_M_right;</span><br><span class="line">    <span class="comment">//node有左节点，左子节点的最右节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_M_node-&gt;_M_left != <span class="number">0</span>) &#123;</span><br><span class="line">      _Base_ptr __y = _M_node-&gt;_M_left;</span><br><span class="line">      <span class="keyword">while</span> (__y-&gt;_M_right != <span class="number">0</span>)</span><br><span class="line">        __y = __y-&gt;_M_right;</span><br><span class="line">      _M_node = __y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父父……节点，直到节点是右子节点，返回node=y</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Base_ptr __y = _M_node-&gt;_M_parent;</span><br><span class="line">      <span class="keyword">while</span> (_M_node == __y-&gt;_M_left) &#123;</span><br><span class="line">        _M_node = __y;</span><br><span class="line">        __y = __y-&gt;_M_parent;</span><br><span class="line">      &#125;</span><br><span class="line">      _M_node = __y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// iterator 对应的就是 node 了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Value, <span class="keyword">class</span> _Ref, <span class="keyword">class</span> _Ptr&gt;</span><br><span class="line"><span class="keyword">struct</span> _Rb_tree_iterator : <span class="keyword">public</span> _Rb_tree_base_iterator</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> _Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_iterator&lt;_Value, _Value&amp;, _Value*&gt;             </span><br><span class="line">    iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_iterator&lt;_Value, <span class="keyword">const</span> _Value&amp;, <span class="keyword">const</span> _Value*&gt; </span><br><span class="line">    const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_iterator&lt;_Value, _Ref, _Ptr&gt;                   </span><br><span class="line">    _Self;</span><br><span class="line">  <span class="comment">//link_type是node</span></span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_node&lt;_Value&gt;* _Link_type;</span><br><span class="line"></span><br><span class="line">  _Rb_tree_iterator() &#123;&#125;</span><br><span class="line">  <span class="comment">// 是node 赋给了node_base 所以下面需要强制转换</span></span><br><span class="line">  _Rb_tree_iterator(_Link_type __x) &#123; _M_node = __x; &#125;</span><br><span class="line">  _Rb_tree_iterator(<span class="keyword">const</span> iterator&amp; __it) &#123; _M_node = __it._M_node; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//需要强制转换，才有value_field属性</span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; return _Link_type(_M_node)-&gt;_M_value_field; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; return &amp;(operator*()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>++() &#123; _M_increment(); return *<span class="keyword">this</span>; &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    _M_increment();</span><br><span class="line">    return __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>--() &#123; _M_decrement(); return *<span class="keyword">this</span>; &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    _M_decrement();</span><br><span class="line">    return __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">struct</span> _Rb_tree_base</span><br><span class="line">  : <span class="keyword">public</span> _Rb_tree_alloc_base&lt;_Tp, _Alloc,</span><br><span class="line">                               _Alloc_traits&lt;_Tp, _Alloc&gt;::_S_instanceless&gt;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 一开始就要给header赋值</span></span><br><span class="line">  _Rb_tree_base(<span class="keyword">const</span> allocator_type&amp; __a) </span><br><span class="line">    : _Base(__a) &#123; _M_header = _M_get_node(); &#125;</span><br><span class="line">  ~_Rb_tree_base() &#123; _M_put_node(_M_header); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Key, <span class="keyword">class</span> _Value, <span class="keyword">class</span> _KeyOfValue, </span><br><span class="line">          <span class="keyword">class</span> _Compare, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;</span><br><span class="line">  ::erase(iterator __position)</span><br><span class="line">&#123;</span><br><span class="line">  _Link_type __y = </span><br><span class="line">    (_Link_type) _Rb_tree_rebalance_for_erase(__position._M_node,</span><br><span class="line">                                              _M_header-&gt;_M_parent,</span><br><span class="line">                                              _M_header-&gt;_M_left,</span><br><span class="line">                                              _M_header-&gt;_M_right);</span><br><span class="line">  destroy_node(__y);</span><br><span class="line">  --_M_node_count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除key=__x的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Key, <span class="keyword">class</span> _Value, <span class="keyword">class</span> _KeyOfValue, </span><br><span class="line">          <span class="keyword">class</span> _Compare, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">typename</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::size_type </span><br><span class="line">_Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::erase(<span class="keyword">const</span> _Key&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line">  pair&lt;iterator,iterator&gt; __p = equal_range(__x);</span><br><span class="line">  size_type __n = <span class="number">0</span>;</span><br><span class="line">  distance(__p.first, __p.second, __n);</span><br><span class="line">  erase(__p.first, __p.second);</span><br><span class="line">  return __n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是Link_type,递归的删除__x的所有子节点还有__x本身。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Key, <span class="keyword">class</span> _Value, <span class="keyword">class</span> _KeyOfValue, </span><br><span class="line">          <span class="keyword">class</span> _Compare, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;</span><br><span class="line">  ::_M_erase(_Link_type __x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// erase without rebalancing</span></span><br><span class="line">  <span class="keyword">while</span> (__x != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//删除右节点</span></span><br><span class="line">    _M_erase(_S_right(__x));</span><br><span class="line">    _Link_type __y = _S_left(__x);</span><br><span class="line">    destroy_node(__x);</span><br><span class="line">    <span class="comment">//设为左节点，所以右节点是递归删除，左节点是while 来 destroy</span></span><br><span class="line">    __x = __y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//earse可以接受的参数类型还挺多的。底下两个是删除区域</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Key, <span class="keyword">class</span> _Value, <span class="keyword">class</span> _KeyOfValue, </span><br><span class="line">          <span class="keyword">class</span> _Compare, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;</span><br><span class="line">  ::erase(iterator __first, iterator __last)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__first == begin() &amp;&amp; __last == end())</span><br><span class="line">    clear();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">while</span> (__first != __last) erase(__first++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Key, <span class="keyword">class</span> _Value, <span class="keyword">class</span> _KeyOfValue, </span><br><span class="line">          <span class="keyword">class</span> _Compare, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;</span><br><span class="line">  ::erase(<span class="keyword">const</span> _Key* __first, <span class="keyword">const</span> _Key* __last) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (__first != __last) erase(*__first++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Key, <span class="keyword">class</span> _Value, <span class="keyword">class</span> _KeyOfValue, <span class="keyword">class</span> _Compare,</span><br><span class="line">          <span class="keyword">class</span> _Alloc = __STL_DEFAULT_ALLOCATOR(_Value) &gt;</span><br><span class="line"><span class="keyword">class</span> _Rb_tree : <span class="keyword">protected</span> _Rb_tree_base&lt;_Value, _Alloc&gt; &#123;</span><br><span class="line">  <span class="comment">// 通过header简单实现，root leftmost 和 rightmost</span></span><br><span class="line">  _Link_type&amp; _M_root() <span class="keyword">const</span> </span><br><span class="line">    &#123; return (_Link_type&amp;) _M_header-&gt;_M_parent; &#125;</span><br><span class="line">  _Link_type&amp; _M_leftmost() <span class="keyword">const</span> </span><br><span class="line">    &#123; return (_Link_type&amp;) _M_header-&gt;_M_left; &#125;</span><br><span class="line">  _Link_type&amp; _M_rightmost() <span class="keyword">const</span> </span><br><span class="line">    &#123; return (_Link_type&amp;) _M_header-&gt;_M_right; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//有参数的构造函数忽略了</span></span><br><span class="line">  _Rb_tree()</span><br><span class="line">    : _Base(allocator_type()), _M_node_count(<span class="number">0</span>), _M_key_compare()</span><br><span class="line">    &#123; _M_empty_initialize(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">void</span> _M_empty_initialize() &#123;</span><br><span class="line">   <span class="comment">// used to distinguish header from </span></span><br><span class="line">   <span class="comment">// __root, in iterator.operator++</span></span><br><span class="line">    _S_color(_M_header) = _S_rb_tree_red; </span><br><span class="line">    _M_root() = <span class="number">0</span>;</span><br><span class="line">    _M_leftmost() = _M_header;</span><br><span class="line">    _M_rightmost() = _M_header;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//分别 set,map  和 multiset,multimap用</span></span><br><span class="line">  pair&lt;iterator,<span class="keyword">bool</span>&gt; insert_unique(<span class="keyword">const</span> value_type&amp; __x);</span><br><span class="line">  <span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="keyword">const</span> value_type&amp; __x)</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">insert_unique</span><span class="params">(iterator __position, <span class="keyword">const</span> value_type&amp; __x)</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">insert_equal</span><span class="params">(iterator __position, <span class="keyword">const</span> value_type&amp; __x)</span></span>;</span><br><span class="line">  <span class="comment">//清空树 </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_node_count != <span class="number">0</span>) &#123;</span><br><span class="line">   	  <span class="comment">// erase(link_type) 删除所有节点</span></span><br><span class="line">      _M_erase(_M_root());</span><br><span class="line">      _M_leftmost() = _M_header;</span><br><span class="line">      _M_root() = <span class="number">0</span>;</span><br><span class="line">      _M_rightmost() = _M_header;</span><br><span class="line">      _M_node_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终的rb_tree 反正什么都是通过_Rb_tree来弄的。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Key, <span class="keyword">class</span> _Value, <span class="keyword">class</span> _KeyOfValue, <span class="keyword">class</span> _Compare,</span><br><span class="line">          <span class="keyword">class</span> _Alloc = __STL_DEFAULT_ALLOCATOR(_Value) &gt;</span><br><span class="line"><span class="keyword">struct</span> rb_tree : <span class="keyword">public</span> _Rb_tree&lt;_Key, _Value, _KeyOfValue, _Compare, _Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree&lt;_Key, _Value, _KeyOfValue, _Compare, _Alloc&gt; _Base;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base::allocator_type allocator_type;</span><br><span class="line"></span><br><span class="line">  rb_tree(<span class="keyword">const</span> _Compare&amp; __comp = _Compare(),</span><br><span class="line">          <span class="keyword">const</span> allocator_type&amp; __a = allocator_type())</span><br><span class="line">    : _Base(__comp, __a) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  ~rb_tree() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下两个函数寻找lower_bound 和 upper_bound。</span></span><br><span class="line"><span class="comment">//设置y这个参数挺机智的。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Key, <span class="keyword">class</span> _Value, <span class="keyword">class</span> _KeyOfValue, </span><br><span class="line">          <span class="keyword">class</span> _Compare, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">typename</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::iterator </span><br><span class="line">_Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;</span><br><span class="line">  ::lower_bound(<span class="keyword">const</span> _Key&amp; __k)</span><br><span class="line">&#123;</span><br><span class="line">  _Link_type __y = _M_header; <span class="comment">/* Last node which is not less than __k. */</span></span><br><span class="line">  _Link_type __x = _M_root(); <span class="comment">/* Current node. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__x != <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">if</span> (!_M_key_compare(_S_key(__x), __k))</span><br><span class="line">      __y = __x, __x = _S_left(__x);<span class="comment">// update y</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      __x = _S_right(__x);<span class="comment">//no update y</span></span><br><span class="line"></span><br><span class="line">  return iterator(__y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Key, <span class="keyword">class</span> _Value, <span class="keyword">class</span> _KeyOfValue, </span><br><span class="line">          <span class="keyword">class</span> _Compare, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">typename</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::const_iterator </span><br><span class="line">_Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;</span><br><span class="line">  ::lower_bound(<span class="keyword">const</span> _Key&amp; __k) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  _Link_type __y = _M_header; <span class="comment">/* Last node which is not less than __k. */</span></span><br><span class="line">  _Link_type __x = _M_root(); <span class="comment">/* Current node. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__x != <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">if</span> (!_M_key_compare(_S_key(__x), __k))</span><br><span class="line">      __y = __x, __x = _S_left(__x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      __x = _S_right(__x);</span><br><span class="line"></span><br><span class="line">  return const_iterator(__y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重头戏</span></span><br><span class="line"><span class="comment">//左转，右转还比较简单</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">_Rb_tree_rotate_left(_Rb_tree_node_base* __x, _Rb_tree_node_base*&amp; __root)</span><br><span class="line">&#123;</span><br><span class="line">  _Rb_tree_node_base* __y = __x-&gt;_M_right;</span><br><span class="line">  __x-&gt;_M_right = __y-&gt;_M_left;</span><br><span class="line">  <span class="keyword">if</span> (__y-&gt;_M_left !=<span class="number">0</span>)</span><br><span class="line">    __y-&gt;_M_left-&gt;_M_parent = __x;</span><br><span class="line">  __y-&gt;_M_parent = __x-&gt;_M_parent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__x == __root)</span><br><span class="line">    __root = __y;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__x == __x-&gt;_M_parent-&gt;_M_left)</span><br><span class="line">    __x-&gt;_M_parent-&gt;_M_left = __y;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __x-&gt;_M_parent-&gt;_M_right = __y;</span><br><span class="line">  __y-&gt;_M_left = __x;</span><br><span class="line">  __x-&gt;_M_parent = __y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">_Rb_tree_rotate_right(_Rb_tree_node_base* __x, _Rb_tree_node_base*&amp; __root)</span><br><span class="line">&#123;</span><br><span class="line">  _Rb_tree_node_base* __y = __x-&gt;_M_left;</span><br><span class="line">  __x-&gt;_M_left = __y-&gt;_M_right;</span><br><span class="line">  <span class="keyword">if</span> (__y-&gt;_M_right != <span class="number">0</span>)</span><br><span class="line">    __y-&gt;_M_right-&gt;_M_parent = __x;</span><br><span class="line">  __y-&gt;_M_parent = __x-&gt;_M_parent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__x == __root)</span><br><span class="line">    __root = __y;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__x == __x-&gt;_M_parent-&gt;_M_right)</span><br><span class="line">    __x-&gt;_M_parent-&gt;_M_right = __y;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __x-&gt;_M_parent-&gt;_M_left = __y;</span><br><span class="line">  __y-&gt;_M_right = __x;</span><br><span class="line">  __x-&gt;_M_parent = __y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">_Rb_tree_rebalance(_Rb_tree_node_base* __x, _Rb_tree_node_base*&amp; __root)</span><br><span class="line">&#123;</span><br><span class="line">  __x-&gt;_M_color = _S_rb_tree_red;<span class="comment">//新节点必为红</span></span><br><span class="line">  <span class="comment">//如果x不是根节点，且父节点为红</span></span><br><span class="line">  <span class="keyword">while</span> (__x != __root &amp;&amp; __x-&gt;_M_parent-&gt;_M_color == _S_rb_tree_red) &#123;</span><br><span class="line">    <span class="comment">//父节点为祖父节点的左节点</span></span><br><span class="line">    <span class="keyword">if</span> (__x-&gt;_M_parent == __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_left) &#123;</span><br><span class="line">      <span class="comment">//伯父节点为y</span></span><br><span class="line">      _Rb_tree_node_base* __y = __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_right;</span><br><span class="line">      <span class="comment">// 如果伯父节点存在且为红</span></span><br><span class="line">      <span class="keyword">if</span> (__y &amp;&amp; __y-&gt;_M_color == _S_rb_tree_red) &#123;</span><br><span class="line">        <span class="comment">//那么首先祖父节点为黑，祖父变红，父和伯父变黑。</span></span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">        __y-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_color = _S_rb_tree_red;</span><br><span class="line">        <span class="comment">// x更新为祖父节点</span></span><br><span class="line">        __x = __x-&gt;_M_parent-&gt;_M_parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 伯父节点不存在或为黑，其实不存在也是黑</span></span><br><span class="line">        <span class="comment">// 如果x是右节点</span></span><br><span class="line">        <span class="keyword">if</span> (__x == __x-&gt;_M_parent-&gt;_M_right) &#123;</span><br><span class="line">          __x = __x-&gt;_M_parent;</span><br><span class="line">          _Rb_tree_rotate_left(__x, __root);<span class="comment">//parent左转</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后右转，左节点只要单旋转，右节点要双旋转</span></span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_color = _S_rb_tree_red;</span><br><span class="line">        _Rb_tree_rotate_right(__x-&gt;_M_parent-&gt;_M_parent, __root);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父节点为祖父节点的右节点了</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//伯父节点</span></span><br><span class="line">      _Rb_tree_node_base* __y = __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_left;</span><br><span class="line">      <span class="comment">//跟上面的if差不多。</span></span><br><span class="line">      <span class="comment">//如果伯父存在且是红</span></span><br><span class="line">      <span class="keyword">if</span> (__y &amp;&amp; __y-&gt;_M_color == _S_rb_tree_red) &#123;</span><br><span class="line">        <span class="comment">//改颜色，递归</span></span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">        __y-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_color = _S_rb_tree_red;</span><br><span class="line">        __x = __x-&gt;_M_parent-&gt;_M_parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 内侧的话就要双旋转</span></span><br><span class="line">        <span class="keyword">if</span> (__x == __x-&gt;_M_parent-&gt;_M_left) &#123;</span><br><span class="line">          __x = __x-&gt;_M_parent;</span><br><span class="line">          _Rb_tree_rotate_right(__x, __root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//外侧的话就单旋转</span></span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_color = _S_rb_tree_red;</span><br><span class="line">        _Rb_tree_rotate_left(__x-&gt;_M_parent-&gt;_M_parent, __root);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//保证root是黑节点</span></span><br><span class="line">  __root-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////删除一个节点后平衡，超超烦//////////////////////////////</span></span><br><span class="line"><span class="keyword">inline</span> _Rb_tree_node_base*</span><br><span class="line">_Rb_tree_rebalance_for_erase(_Rb_tree_node_base* __z,<span class="comment">//待删除的节点</span></span><br><span class="line">                             _Rb_tree_node_base*&amp; __root,</span><br><span class="line">                             _Rb_tree_node_base*&amp; __leftmost,</span><br><span class="line">                             _Rb_tree_node_base*&amp; __rightmost)</span><br><span class="line">&#123;</span><br><span class="line">  _Rb_tree_node_base* __y = __z;</span><br><span class="line">  _Rb_tree_node_base* __x = <span class="number">0</span>;</span><br><span class="line">  _Rb_tree_node_base* __x_parent = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (__y-&gt;_M_left == <span class="number">0</span>)     <span class="comment">// __z has at most one non-null child. y == z.</span></span><br><span class="line">    __x = __y-&gt;_M_right;     <span class="comment">// __x might be null.</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (__y-&gt;_M_right == <span class="number">0</span>)  <span class="comment">// __z has exactly one non-null child. y == z.</span></span><br><span class="line">      __x = __y-&gt;_M_left;    <span class="comment">// __x is not null.</span></span><br><span class="line">    <span class="keyword">else</span> &#123;                   <span class="comment">// __z has two non-null children.  Set __y to</span></span><br><span class="line">      __y = __y-&gt;_M_right;   <span class="comment">//   __z's successor.  __x might be null.</span></span><br><span class="line">      <span class="keyword">while</span> (__y-&gt;_M_left != <span class="number">0</span>)</span><br><span class="line">        __y = __y-&gt;_M_left;</span><br><span class="line">      <span class="comment">//y是z的右节点的最左子节点，x是y的右节点,y左节点为null</span></span><br><span class="line">      __x = __y-&gt;_M_right;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//将y替代z</span></span><br><span class="line">  <span class="keyword">if</span> (__y != __z) &#123;          <span class="comment">// relink y in place of z.  y is z's successor</span></span><br><span class="line">    __z-&gt;_M_left-&gt;_M_parent = __y; </span><br><span class="line">    __y-&gt;_M_left = __z-&gt;_M_left;</span><br><span class="line">    <span class="keyword">if</span> (__y != __z-&gt;_M_right) &#123;</span><br><span class="line">      __x_parent = __y-&gt;_M_parent;</span><br><span class="line">      <span class="keyword">if</span> (__x) __x-&gt;_M_parent = __y-&gt;_M_parent;</span><br><span class="line">      __y-&gt;_M_parent-&gt;_M_left = __x;      <span class="comment">// __y must be a child of _M_left</span></span><br><span class="line">      __y-&gt;_M_right = __z-&gt;_M_right;</span><br><span class="line">      __z-&gt;_M_right-&gt;_M_parent = __y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      __x_parent = __y;  </span><br><span class="line">    <span class="keyword">if</span> (__root == __z)</span><br><span class="line">      __root = __y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__z-&gt;_M_parent-&gt;_M_left == __z)</span><br><span class="line">      __z-&gt;_M_parent-&gt;_M_left = __y;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      __z-&gt;_M_parent-&gt;_M_right = __y;</span><br><span class="line">    __y-&gt;_M_parent = __z-&gt;_M_parent;</span><br><span class="line">    __STD::swap(__y-&gt;_M_color, __z-&gt;_M_color);</span><br><span class="line">    __y = __z;</span><br><span class="line">    <span class="comment">// __y now points to node to be actually deleted</span></span><br><span class="line">    <span class="comment">//现在 y 变成了z，需要删除的节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;                        <span class="comment">// __y == __z</span></span><br><span class="line">    <span class="comment">//y == z 的话，直接用x替代y</span></span><br><span class="line">    __x_parent = __y-&gt;_M_parent;</span><br><span class="line">    <span class="keyword">if</span> (__x) __x-&gt;_M_parent = __y-&gt;_M_parent;   </span><br><span class="line">    <span class="keyword">if</span> (__root == __z)</span><br><span class="line">      __root = __x;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">if</span> (__z-&gt;_M_parent-&gt;_M_left == __z)</span><br><span class="line">        __z-&gt;_M_parent-&gt;_M_left = __x;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        __z-&gt;_M_parent-&gt;_M_right = __x;</span><br><span class="line">    <span class="keyword">if</span> (__leftmost == __z) </span><br><span class="line">      <span class="keyword">if</span> (__z-&gt;_M_right == <span class="number">0</span>)        <span class="comment">// __z-&gt;_M_left must be null also</span></span><br><span class="line">        __leftmost = __z-&gt;_M_parent;</span><br><span class="line">    <span class="comment">// makes __leftmost == _M_header if __z == __root</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        __leftmost = _Rb_tree_node_base::_S_minimum(__x);</span><br><span class="line">    <span class="keyword">if</span> (__rightmost == __z)  </span><br><span class="line">      <span class="keyword">if</span> (__z-&gt;_M_left == <span class="number">0</span>)         <span class="comment">// __z-&gt;_M_right must be null also</span></span><br><span class="line">        __rightmost = __z-&gt;_M_parent;  </span><br><span class="line">    <span class="comment">// makes __rightmost == _M_header if __z == __root</span></span><br><span class="line">      <span class="keyword">else</span>                      <span class="comment">// __x == __z-&gt;_M_left</span></span><br><span class="line">        __rightmost = _Rb_tree_node_base::_S_maximum(__x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//y 颜色是红的话，删掉就删掉了。y颜色是黑的，才需要平衡</span></span><br><span class="line">  <span class="keyword">if</span> (__y-&gt;_M_color != _S_rb_tree_red) &#123; </span><br><span class="line">    <span class="comment">//如果x是红色节点的话，把x变黑，就好了。不然才要while </span></span><br><span class="line">    <span class="keyword">while</span> (__x != __root &amp;&amp; (__x == <span class="number">0</span> || __x-&gt;_M_color == _S_rb_tree_black))</span><br><span class="line">      <span class="keyword">if</span> (__x == __x_parent-&gt;_M_left) &#123;</span><br><span class="line">        <span class="comment">//x是左节点，黑色, w是其兄弟节点</span></span><br><span class="line">        _Rb_tree_node_base* __w = __x_parent-&gt;_M_right;</span><br><span class="line">        <span class="keyword">if</span> (__w-&gt;_M_color == _S_rb_tree_red) &#123;</span><br><span class="line">          <span class="comment">//w是红的话，左转并变色,w变为父节点，继续判断</span></span><br><span class="line">          __w-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">          __x_parent-&gt;_M_color = _S_rb_tree_red;</span><br><span class="line">          _Rb_tree_rotate_left(__x_parent, __root);</span><br><span class="line">          __w = __x_parent-&gt;_M_right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//W现在已经是黑的了，如果w为红，上一步已经旋转过了，然后变黑。或者本来就黑</span></span><br><span class="line">        <span class="keyword">if</span> ((__w-&gt;_M_left == <span class="number">0</span> || </span><br><span class="line">             __w-&gt;_M_left-&gt;_M_color == _S_rb_tree_black) &amp;&amp;</span><br><span class="line">            (__w-&gt;_M_right == <span class="number">0</span> || </span><br><span class="line">             __w-&gt;_M_right-&gt;_M_color == _S_rb_tree_black)) &#123;</span><br><span class="line">          <span class="comment">//如果w的2个子节点都是黑黑黑,w变红，这样w的子树和x的子树节点数一样了，都少一个，x变为父节点，重新判断</span></span><br><span class="line">          __w-&gt;_M_color = _S_rb_tree_red;</span><br><span class="line">          __x = __x_parent;</span><br><span class="line">          __x_parent = __x_parent-&gt;_M_parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//这里，w是黑，w有个子节点是红色的</span></span><br><span class="line">          <span class="keyword">if</span> (__w-&gt;_M_right == <span class="number">0</span> || </span><br><span class="line">              __w-&gt;_M_right-&gt;_M_color == _S_rb_tree_black) &#123;</span><br><span class="line">            <span class="comment">//那么left就是红色的</span></span><br><span class="line">            <span class="keyword">if</span> (__w-&gt;_M_left) __w-&gt;_M_left-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">            __w-&gt;_M_color = _S_rb_tree_red;</span><br><span class="line">            <span class="comment">//左子节点和w，右转，</span></span><br><span class="line">            _Rb_tree_rotate_right(__w, __root);</span><br><span class="line">            __w = __x_parent-&gt;_M_right;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 右转，然后x的字数上就多了一个黑节点，满足平衡了，break</span></span><br><span class="line">          __w-&gt;_M_color = __x_parent-&gt;_M_color;</span><br><span class="line">          __x_parent-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">          <span class="keyword">if</span> (__w-&gt;_M_right) __w-&gt;_M_right-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">          _Rb_tree_rotate_left(__x_parent, __root);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//下面就是x是右节点的情况了。其他都对应着来。</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;                  <span class="comment">// same as above, with _M_right &lt;-&gt; _M_left.</span></span><br><span class="line">        _Rb_tree_node_base* __w = __x_parent-&gt;_M_left;</span><br><span class="line">        <span class="keyword">if</span> (__w-&gt;_M_color == _S_rb_tree_red) &#123;</span><br><span class="line">          __w-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">          __x_parent-&gt;_M_color = _S_rb_tree_red;</span><br><span class="line">          _Rb_tree_rotate_right(__x_parent, __root);</span><br><span class="line">          __w = __x_parent-&gt;_M_left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((__w-&gt;_M_right == <span class="number">0</span> || </span><br><span class="line">             __w-&gt;_M_right-&gt;_M_color == _S_rb_tree_black) &amp;&amp;</span><br><span class="line">            (__w-&gt;_M_left == <span class="number">0</span> || </span><br><span class="line">             __w-&gt;_M_left-&gt;_M_color == _S_rb_tree_black)) &#123;</span><br><span class="line">          __w-&gt;_M_color = _S_rb_tree_red;</span><br><span class="line">          __x = __x_parent;</span><br><span class="line">          __x_parent = __x_parent-&gt;_M_parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (__w-&gt;_M_left == <span class="number">0</span> || </span><br><span class="line">              __w-&gt;_M_left-&gt;_M_color == _S_rb_tree_black) &#123;</span><br><span class="line">            <span class="keyword">if</span> (__w-&gt;_M_right) __w-&gt;_M_right-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">            __w-&gt;_M_color = _S_rb_tree_red;</span><br><span class="line">            _Rb_tree_rotate_left(__w, __root);</span><br><span class="line">            __w = __x_parent-&gt;_M_left;</span><br><span class="line">          &#125;</span><br><span class="line">          __w-&gt;_M_color = __x_parent-&gt;_M_color;</span><br><span class="line">          __x_parent-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">          <span class="keyword">if</span> (__w-&gt;_M_left) __w-&gt;_M_left-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">          _Rb_tree_rotate_right(__x_parent, __root);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (__x) __x-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">  &#125;</span><br><span class="line">  return __y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下是插入节点，有unique 和 equal 两种情况,都是找出对应位置，具体的都是通过M_insert()来完成。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Key, <span class="keyword">class</span> _Value, <span class="keyword">class</span> _KeyOfValue, </span><br><span class="line">          <span class="keyword">class</span> _Compare, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">typename</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::iterator</span><br><span class="line">_Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;</span><br><span class="line">  ::_M_insert(_Base_ptr __x_, _Base_ptr __y_, <span class="keyword">const</span> _Value&amp; __v)</span><br><span class="line">&#123;</span><br><span class="line">  _Link_type __x = (_Link_type) __x_;</span><br><span class="line">  _Link_type __y = (_Link_type) __y_;</span><br><span class="line">  _Link_type __z;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__y == _M_header || __x != <span class="number">0</span> || </span><br><span class="line">      _M_key_compare(_KeyOfValue()(__v), _S_key(__y))) &#123;</span><br><span class="line">    __z = _M_create_node(__v);</span><br><span class="line">    _S_left(__y) = __z;               <span class="comment">// also makes _M_leftmost() = __z </span></span><br><span class="line">                                      <span class="comment">//    when __y == _M_header</span></span><br><span class="line">    <span class="keyword">if</span> (__y == _M_header) &#123;</span><br><span class="line">      _M_root() = __z;</span><br><span class="line">      _M_rightmost() = __z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__y == _M_leftmost())</span><br><span class="line">      _M_leftmost() = __z;   <span class="comment">// maintain _M_leftmost() pointing to min node</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    __z = _M_create_node(__v);</span><br><span class="line">    _S_right(__y) = __z;</span><br><span class="line">    <span class="keyword">if</span> (__y == _M_rightmost())</span><br><span class="line">      _M_rightmost() = __z;  <span class="comment">// maintain _M_rightmost() pointing to max node</span></span><br><span class="line">  &#125;</span><br><span class="line">  _S_parent(__z) = __y;</span><br><span class="line">  _S_left(__z) = <span class="number">0</span>;</span><br><span class="line">  _S_right(__z) = <span class="number">0</span>;</span><br><span class="line">  _Rb_tree_rebalance(__z, _M_header-&gt;_M_parent);</span><br><span class="line">  ++_M_node_count;</span><br><span class="line">  return iterator(__z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert equal，可以插入相同的key</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Key, <span class="keyword">class</span> _Value, <span class="keyword">class</span> _KeyOfValue, </span><br><span class="line">          <span class="keyword">class</span> _Compare, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">typename</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::iterator</span><br><span class="line">_Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;</span><br><span class="line">  ::insert_equal(<span class="keyword">const</span> _Value&amp; __v)</span><br><span class="line">&#123;</span><br><span class="line">  _Link_type __y = _M_header;</span><br><span class="line">  _Link_type __x = _M_root();</span><br><span class="line">  <span class="keyword">while</span> (__x != <span class="number">0</span>) &#123;</span><br><span class="line">    __y = __x;</span><br><span class="line">    __x = _M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ? </span><br><span class="line">            _S_left(__x) : _S_right(__x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// y 是满足 compare(v,y)的最小值或者最右节点，反正就是适合插入的位置,x = 0</span></span><br><span class="line">  return _M_insert(__x, __y, __v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert unique，如果key已存在，则不插入，直接返回，否则插入</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Key, <span class="keyword">class</span> _Value, <span class="keyword">class</span> _KeyOfValue, </span><br><span class="line">          <span class="keyword">class</span> _Compare, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line">pair&lt;<span class="keyword">typename</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::iterator, </span><br><span class="line">     <span class="keyword">bool</span>&gt;</span><br><span class="line">_Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;</span><br><span class="line">  ::insert_unique(<span class="keyword">const</span> _Value&amp; __v)</span><br><span class="line">&#123;</span><br><span class="line">  _Link_type __y = _M_header;</span><br><span class="line">  _Link_type __x = _M_root();</span><br><span class="line">  <span class="keyword">bool</span> __comp = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">//目标找到满足comapare()的最左边点</span></span><br><span class="line">  <span class="keyword">while</span> (__x != <span class="number">0</span>) &#123;</span><br><span class="line">    __y = __x;</span><br><span class="line">    __comp = _M_key_compare(_KeyOfValue()(__v), _S_key(__x));</span><br><span class="line">    __x = __comp ? _S_left(__x) : _S_right(__x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//y是link_type，得到iterator</span></span><br><span class="line">  iterator __j = iterator(__y);  </span><br><span class="line">  <span class="comment">//如果满足comp，即 y &gt; v</span></span><br><span class="line">  <span class="keyword">if</span> (__comp)</span><br><span class="line">    <span class="keyword">if</span> (__j == begin())     </span><br><span class="line">      return pair&lt;iterator,<span class="keyword">bool</span>&gt;(_M_insert(__x, __y, __v), true);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">   	 	<span class="comment">//找到上一个j.理论上减完之后j应该小于v了。</span></span><br><span class="line">      --__j;</span><br><span class="line">  <span class="comment">//到这里的话，j应该是要小于v的。</span></span><br><span class="line">  <span class="comment">// 反过来compare一下</span></span><br><span class="line">  <span class="comment">// j&lt; v的话，是对的。家插入</span></span><br><span class="line">  <span class="keyword">if</span> (_M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))</span><br><span class="line">    return pair&lt;iterator,<span class="keyword">bool</span>&gt;(_M_insert(__x, __y, __v), true);</span><br><span class="line">  <span class="comment">// 否则，v对应的key意见存在了。</span></span><br><span class="line">  <span class="comment">// 已存在的话，返回的pair.second是false</span></span><br><span class="line">  return pair&lt;iterator,<span class="keyword">bool</span>&gt;(__j, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/18/STL-5/" data-id="ciofwrhd9000c21nqtpcms4ln" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-STL/">C++ STL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-STL-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/16/STL-4/" class="article-date">
  <time datetime="2016-05-16T05:16:04.000Z" itemprop="datePublished">2016-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/16/STL-4/">STL源码剖析（4）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><p>感觉之前代码贴太多了，接下来少放点代码。</p>
<p>标准的STL关联式容器分为set（集合）和map（映射表）两大类，以及其衍生体multiset和multimap。容器的底层机制均已RB-tree红黑树来完成。</p>
<p>set与map的区别主要是set中键和值是一样的，而map对应的key-value并不一样。</p>
<p>multiset与set和multimap和map之间的区别是multi-系列使用的是<code>Insert-equal()</code>，内部允许重复，而set,map使用的是<code>Insert-unique()</code>，内部没有重复。</p>
<h2 id="树型结构"><a href="#树型结构" class="headerlink" title="树型结构"></a>树型结构</h2><p>树是由节点（nodes）和边（edges）构成。整棵树最上端的节点称为根节点。相连节点之中，在上者称为父节点（parent），在下者称为子节点（child）,无子节点这称为叶节点（leaf）。子节点可以存在多个，如果最多只能有2个子节点，即所谓二叉树(binary tree)。</p>
<p>不同子节点如果拥有同一个父节点，则为兄弟节点（siblings）。根节点至任何节点之间有唯一路径（path），路径所经过的边数，称为路径长度（length）。跟节点至任一节点的路径长度，即该节点的深度（depth）。根节点深度为0。某节点至其最深子节点的路径长度，称为该节点的高度（height）。整棵树的高度，以根节点的高度来表示。</p>
<p><strong>二叉搜索树</strong> 可提供对数时间的元素插入和访问。其放置规则是：任何节点的键值一定大于其左子树的每个节点的键值，小于右子树的每一个节点的键值。</p>
<p><strong>平衡二叉搜索树</strong> AVL-Tree， RB-Tree， AA-Tree。没有任何一个节点深度过大。</p>
<p><a href="http://blog.csdn.net/whucyl/article/details/17289841" target="_blank" rel="external"><strong>AVL-Tree</strong></a>  要求任何节点的左右子树高度相差最多1。不平衡的时候通过对子树进行旋转维持整树的平衡。</p>
<p><strong>插入节点时</strong>，插入点至根节点路径上各节点可能改变平衡状态，因此，只要调整其中最深的那个节点，便可使整棵树重新获得平衡。假设平衡被破坏的各节点中最深的一个节点为X，情况分为以下4种：</p>
<ol>
<li>插入点位于X的<strong>左</strong>子节点的<strong>左</strong>子树：左左</li>
<li>插入点位于X的<strong>左</strong>子节点的<strong>右</strong>子树：左右</li>
<li>插入点位于X的<strong>右</strong>子节点的<strong>左</strong>子树：右左</li>
<li>插入点位于X的<strong>右</strong>子节点的<strong>右</strong>子树：右右</li>
</ol>
<p>1，4情况彼此对称，称为外侧插入，采用单旋转操作；</p>
<p>2，3情况彼此对称，称为内侧插入，采用双旋转操作。</p>
<p><strong>删除节点时</strong>，首先找到要删除的节点，如果</p>
<ol>
<li>该节点是叶节点，直接删除；</li>
<li>该节点有左子树不为空，将该节点替换为左子树的最右叶节点；</li>
<li>否则，将该节点替换为右子树的最左节点。</li>
</ol>
<p>然后，从被替换的叶节点开始往上判断，是否不平衡，若不平衡，则旋转平衡。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树（RB-Tree）不仅是一个二叉搜索树，而且必须满足一下特征：</p>
<ol>
<li>每个节点不是红色就是黑色；</li>
<li>根节点为黑色；</li>
<li>如果节点为红色，其子节点必须为黑；</li>
<li>任一节点至NULL（树尾端）的任何路径，所含的黑节点数必须相同。</li>
</ol>
<p>引申：</p>
<ol>
<li>不存在父节点和子节点都为红色；</li>
<li>新增节点时初始颜色为红色（平衡过后可能为黑）；</li>
<li>新增节点之父节点必须为黑色（否则需平衡）；</li>
<li>空节点可视为黑节点。</li>
</ol>
<p>红黑树太繁琐了，不写了。书210页。贴个链接。<a href="http://www.cnblogs.com/fornever/archive/2011/12/02/2270692.html" target="_blank" rel="external">http://www.cnblogs.com/fornever/archive/2011/12/02/2270692.html</a></p>
<p>以下跟SGI STL 的红黑树实现可能不一样。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>若父节点为黑，则不需平衡。</p>
<p>若父节点为红，则看父节点的兄弟节点。且G为黑，GG不定。</p>
<p>设插入节点为X，父节点为P，父节点兄弟节点为S，祖父节点为G，组祖父为GG。</p>
<ol>
<li>若S为黑，且X为外侧插入。先对PG做单旋，然后更改PG颜色。</li>
<li>若S为黑，且X为内侧插入。先PX单旋，改变GX颜色，在对G做一次单旋。</li>
<li>若S为红，P也是红，则直接把G改为红，PS改为黑。然后X为P，P为G，G为GG，S为GG-&gt;right,重新判断。（跟书上不一样，书上没说S为红且为内插的时候的情况）</li>
</ol>
<p>为了方便，避免递归判断的情况，有一个从上到下的程序：沿着插入节点的路径，从上到下，只要X的两个子节点都是红，则X改为红，两个子节点改为黑，然后再插入的叶节点进行一个单或双旋转，这样不会存在递归的问题。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>红黑树的删除是通过找到一个替换节点替换目标节点，然后删除目标节点来实现的。替代节点N至少有一个子节点为NULL。</p>
<ol>
<li>若N为红色，则其为叶节点（否则其子节点就是黑色，与他兄弟节点（NULL）的黑色节点数就不一样了）。直接把N删掉就行。</li>
<li>若N为黑色，且另一子节点M不为NULL，那么M必为红色叶节点，直接把M替换N，然后删除M就行。</li>
<li>若N为黑色，且为叶节点，则删除N后，破坏了平衡树性质4。需要进行相应操作，假设父节点为P，N的<strong>兄弟节点</strong>为S：<ol>
<li>若S为红，则P为黑，PS旋转，并变色。然后重新对N判断。</li>
<li>以下情况S为黑。<ol>
<li>若P为红，S的2个子节点都为黑，则将PS变色，结束。</li>
<li>若P为黑，S的2个子节点都为黑，则S变为红，将N设为P，重新平衡。</li>
<li>P任意色，若N为P的左节点：<ol>
<li>S右节点SR为红，则PS旋转，SR设为黑，P设为黑，S设为P的颜色。结束。</li>
<li>S左节点SL为红，则SL和S旋转，SL设为黑，S设为红，这样就变成了上面情况。</li>
</ol>
</li>
<li>P任意色，若N为P的右节点:<ol>
<li>若S左节点SL为红，则PS旋转，SL为黑，P为黑，S为P颜色，结束。</li>
<li>若S右节点SR为红，则SR和S旋转，SR为黑，S为红，转为上面情况。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>至此，删除节点完成。接下来就看看SGI STL中RB-Tree的代码实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/16/STL-4/" data-id="ciofwrhcz000821nq3xdam3vu" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-STL/">C++ STL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-union-find" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/02/union-find/" class="article-date">
  <time datetime="2016-05-02T12:36:59.000Z" itemprop="datePublished">2016-05-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/02/union-find/">并查集union-find</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>并查集。简单实现及路径压缩。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="comment">// in initial ,the parent = this.</span></span><br><span class="line">    Node parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// find the root node of a</span></span><br><span class="line"><span class="function">Node <span class="title">find</span><span class="params">(Node a)</span> </span>&#123;</span><br><span class="line">    Node tmp = a;</span><br><span class="line">    <span class="comment">// get the root</span></span><br><span class="line">    <span class="keyword">while</span> (tmp.parent != tmp) &#123;</span><br><span class="line">        tmp = tmp.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    Node i = a, j;</span><br><span class="line">    <span class="comment">// compress the route</span></span><br><span class="line">    <span class="keyword">while</span> (i != tmp) &#123;</span><br><span class="line">        j = i.parent;</span><br><span class="line">        i.parent = tmp;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// join two sets into one</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">join</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">    Node pa = find(a);</span><br><span class="line">    Node pb = find(b);</span><br><span class="line">    <span class="keyword">if</span> (pa != pb) &#123;</span><br><span class="line">        pa.parent = pb;</span><br><span class="line">        <span class="comment">// join</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// already in one set</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/02/union-find/" data-id="ciofwrhcs000421nqq0zbgn4d" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/图-路径压缩/">图 路径压缩</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-STL-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/28/STL-3/" class="article-date">
  <time datetime="2016-04-28T09:39:49.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/STL-3/">STL源码剖析（3）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>deque 是一种双向开口的“连续”线性空间，即可以在头尾两端分别做元素的插入和删除操作。</p>
<p>外部接口看起来是连续的，内部是多个内存块的组合。近似连续。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Ref, <span class="keyword">class</span> _Ptr&gt;</span><br><span class="line"><span class="keyword">struct</span> _Deque_iterator &#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp, <span class="keyword">const</span> _Tp&amp;, <span class="keyword">const</span> _Tp*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> _S_buffer_size() &#123; return __deque_buf_size(sizeof(_Tp)); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rando access,可以随机访问</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp** _Map_pointer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator _Self;</span><br><span class="line">  <span class="comment">// 一个iterator包含一块缓冲区的信息</span></span><br><span class="line">  <span class="comment">// 指向当前内容</span></span><br><span class="line">  _Tp* _M_cur;</span><br><span class="line">  <span class="comment">// 该缓冲区头部</span></span><br><span class="line">  _Tp* _M_first;</span><br><span class="line">  <span class="comment">// 尾部</span></span><br><span class="line">  _Tp* _M_last;</span><br><span class="line">  <span class="comment">// 指向对应的总的map的节点指针</span></span><br><span class="line">  _Map_pointer _M_node;</span><br><span class="line"></span><br><span class="line">  _Deque_iterator(_Tp* __x, _Map_pointer __y) </span><br><span class="line">    : _M_cur(__x), _M_first(*__y),</span><br><span class="line">      _M_last(*__y + _S_buffer_size()), _M_node(__y) &#123;&#125;</span><br><span class="line">  _Deque_iterator() : _M_cur(<span class="number">0</span>), _M_first(<span class="number">0</span>), _M_last(<span class="number">0</span>), _M_node(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  _Deque_iterator(<span class="keyword">const</span> iterator&amp; __x)</span><br><span class="line">    : _M_cur(__x._M_cur), _M_first(__x._M_first), </span><br><span class="line">      _M_last(__x._M_last), _M_node(__x._M_node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; return *_M_cur; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; return _M_cur; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//随机访问，指针加减虽然不像vector那样方便，但也就简单的计算就可得出。</span></span><br><span class="line">  difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> _Self&amp; __x) <span class="keyword">const</span> &#123;</span><br><span class="line">    return difference_type(_S_buffer_size()) * (_M_node - __x._M_node - <span class="number">1</span>) +</span><br><span class="line">      (_M_cur - _M_first) + (__x._M_last - __x._M_cur);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    ++_M_cur;</span><br><span class="line">    <span class="keyword">if</span> (_M_cur == _M_last) &#123;</span><br><span class="line">      _M_set_node(_M_node + <span class="number">1</span>);</span><br><span class="line">      _M_cur = _M_first;</span><br><span class="line">    &#125;</span><br><span class="line">    return *<span class="keyword">this</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>++(<span class="keyword">int</span>)  &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    return __tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_cur == _M_first) &#123;</span><br><span class="line">      _M_set_node(_M_node - <span class="number">1</span>);</span><br><span class="line">      _M_cur = _M_last;</span><br><span class="line">    &#125;</span><br><span class="line">    --_M_cur;</span><br><span class="line">    return *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    return __tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>+=(difference_type __n)</span><br><span class="line">  &#123;</span><br><span class="line">    difference_type __offset = __n + (_M_cur - _M_first);</span><br><span class="line">    <span class="keyword">if</span> (__offset &gt;= <span class="number">0</span> &amp;&amp; __offset &lt; difference_type(_S_buffer_size()))</span><br><span class="line">      _M_cur += __n;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      difference_type __node_offset =</span><br><span class="line">        __offset &gt; <span class="number">0</span> ? __offset / difference_type(_S_buffer_size())</span><br><span class="line">                   : -difference_type((-__offset - <span class="number">1</span>) / _S_buffer_size()) - <span class="number">1</span>;</span><br><span class="line">      _M_set_node(_M_node + __node_offset);</span><br><span class="line">      _M_cur = _M_first + </span><br><span class="line">        (__offset - __node_offset * difference_type(_S_buffer_size()));</span><br><span class="line">    &#125;</span><br><span class="line">    return *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Self <span class="keyword">operator</span>+(difference_type __n) <span class="keyword">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    return __tmp += __n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>-=(difference_type __n) &#123; return *<span class="keyword">this</span> += -__n; &#125;</span><br><span class="line"> </span><br><span class="line">  _Self <span class="keyword">operator</span>-(difference_type __n) <span class="keyword">const</span> &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    return __tmp -= __n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 随机访问，返回reference形式，可做左值</span></span><br><span class="line">  reference <span class="keyword">operator</span>[](difference_type __n) <span class="keyword">const</span> &#123; return *(*this + __n); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(const _Self&amp; __x) <span class="keyword">const</span> &#123; return _M_cur == __x._M_cur; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(const _Self&amp; __x) <span class="keyword">const</span> &#123; return !(*this == __x); &#125;</span><br><span class="line">  <span class="comment">// 线比较node指针大小，node一样，则比较对应的cur指针</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> _Self&amp; __x) <span class="keyword">const</span> &#123;</span><br><span class="line">    return (_M_node == __x._M_node) ? </span><br><span class="line">      (_M_cur &lt; __x._M_cur) : (_M_node &lt; __x._M_node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> _Self&amp; __x) <span class="keyword">const</span>  &#123; return __x &lt; *<span class="keyword">this</span>; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(const _Self&amp; __x) <span class="keyword">const</span> &#123; return !(__x &lt; *this); &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(const _Self&amp; __x) <span class="keyword">const</span> &#123; return !(*this &lt; __x); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _M_set_node(_Map_pointer __new_node) &#123;</span><br><span class="line">    _M_node = __new_node;</span><br><span class="line">    _M_first = *__new_node;</span><br><span class="line">    _M_last = _M_first + difference_type(_S_buffer_size());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">class</span> _Deque_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp,_Tp&amp;,_Tp*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp,<span class="keyword">const</span> _Tp&amp;,<span class="keyword">const</span> _Tp*&gt; const_iterator;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> _Alloc allocator_type;</span><br><span class="line">  <span class="function">allocator_type <span class="title">get_allocator</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; return allocator_type(); &#125;</span><br><span class="line"></span><br><span class="line">  _Deque_base(<span class="keyword">const</span> allocator_type&amp;, <span class="keyword">size_t</span> __num_elements)</span><br><span class="line">    : _M_map(<span class="number">0</span>), _M_map_size(<span class="number">0</span>),  _M_start(), _M_finish() &#123;</span><br><span class="line">    _M_initialize_map(__num_elements);</span><br><span class="line">  &#125;</span><br><span class="line">  _Deque_base(<span class="keyword">const</span> allocator_type&amp;)</span><br><span class="line">    : _M_map(<span class="number">0</span>), _M_map_size(<span class="number">0</span>),  _M_start(), _M_finish() &#123;&#125;</span><br><span class="line">  ~_Deque_base();    </span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">void</span> _M_initialize_map(<span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">void</span> _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);</span><br><span class="line">  <span class="keyword">void</span> _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);</span><br><span class="line">  <span class="comment">// 默认的map大小为8快，当然，map节点对应的区域没有初始化，需要再初始化</span></span><br><span class="line">  <span class="keyword">enum</span> &#123; _S_initial_map_size = <span class="number">8</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  _Tp** _M_map;</span><br><span class="line">  <span class="keyword">size_t</span> _M_map_size;</span><br><span class="line">  <span class="comment">// 指向对应的缓冲区buffer</span></span><br><span class="line">  iterator _M_start;</span><br><span class="line">  iterator _M_finish;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;_Tp, _Alloc&gt;  _Node_alloc_type;</span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;_Tp*, _Alloc&gt; _Map_alloc_type;</span><br><span class="line"></span><br><span class="line">  _Tp* _M_allocate_node()</span><br><span class="line">    &#123; return _Node_alloc_type::allocate(__deque_buf_size(sizeof(_Tp))); &#125;</span><br><span class="line">  <span class="keyword">void</span> _M_deallocate_node(_Tp* __p)</span><br><span class="line">    &#123; _Node_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp))); &#125;</span><br><span class="line">  _Tp** _M_allocate_map(<span class="keyword">size_t</span> __n) </span><br><span class="line">    &#123; return _Map_alloc_type::allocate(__n); &#125;</span><br><span class="line">  <span class="keyword">void</span> _M_deallocate_map(_Tp** __p, <span class="keyword">size_t</span> __n) </span><br><span class="line">    &#123; _Map_alloc_type::deallocate(__p, __n); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// num_elements=0的时候，也会先分配一个缓冲区出来</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_Deque_base&lt;_Tp,_Alloc&gt;::_M_initialize_map(<span class="keyword">size_t</span> __num_elements)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">size_t</span> __num_nodes = </span><br><span class="line">    __num_elements / __deque_buf_size(sizeof(_Tp)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  _M_map_size = max((<span class="keyword">size_t</span>) _S_initial_map_size, __num_nodes + <span class="number">2</span>);</span><br><span class="line">  _M_map = _M_allocate_map(_M_map_size);</span><br><span class="line"></span><br><span class="line">  _Tp** __nstart = _M_map + (_M_map_size - __num_nodes) / <span class="number">2</span>;</span><br><span class="line">  _Tp** __nfinish = __nstart + __num_nodes;</span><br><span class="line">    </span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    _M_create_nodes(__nstart, __nfinish);</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND((_M_deallocate_map(_M_map, _M_map_size), </span><br><span class="line">                _M_map = <span class="number">0</span>, _M_map_size = <span class="number">0</span>));</span><br><span class="line">  _M_start._M_set_node(__nstart);</span><br><span class="line">  _M_finish._M_set_node(__nfinish - <span class="number">1</span>);</span><br><span class="line">  _M_start._M_cur = _M_start._M_first;</span><br><span class="line">  _M_finish._M_cur = _M_finish._M_first +</span><br><span class="line">               __num_elements % __deque_buf_size(sizeof(_Tp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class="line">class deque : protected _Deque_base&lt;_Tp, _Alloc&gt; &#123;</span><br><span class="line">public:                         // Constructor, destructor.</span><br><span class="line">  // 初始化_Base的时候都会带上大小。</span><br><span class="line">  explicit deque(const allocator_type&amp; __a = allocator_type()) </span><br><span class="line">    : _Base(__a, 0) &#123;&#125;</span><br><span class="line">  deque(const deque&amp; __x) : _Base(__x.get_allocator(), __x.size()) </span><br><span class="line">    &#123; uninitialized_copy(__x.begin(), __x.end(), _M_start); &#125;</span><br><span class="line">  deque(size_type __n, const value_type&amp; __value,</span><br><span class="line">        const allocator_type&amp; __a = allocator_type()) : _Base(__a, __n)</span><br><span class="line">    &#123; _M_fill_initialize(__value); &#125;</span><br><span class="line">  explicit deque(size_type __n) : _Base(allocator_type(), __n)</span><br><span class="line">    &#123; _M_fill_initialize(value_type()); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Alloc&gt;</span><br><span class="line">void deque&lt;_Tp,_Alloc&gt;::_M_reallocate_map(size_type __nodes_to_add,</span><br><span class="line">                                          bool __add_at_front)</span><br><span class="line">&#123;</span><br><span class="line">  size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + 1;</span><br><span class="line">  size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;</span><br><span class="line"></span><br><span class="line">  _Map_pointer __new_nstart;</span><br><span class="line">  // 如果map大小孩足够大，但是估计是左边或右边到头了，则不申请新的内存，直接copy换个位置就行。</span><br><span class="line">  if (_M_map_size &gt; 2 * __new_num_nodes) &#123;</span><br><span class="line">    __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / 2 </span><br><span class="line">                     + (__add_at_front ? __nodes_to_add : 0);</span><br><span class="line">    if (__new_nstart &lt; _M_start._M_node)</span><br><span class="line">      //一个是copy，从前往后复制</span><br><span class="line">      copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);</span><br><span class="line">    else</span><br><span class="line">      // 一个是copy_backward，从后往前复制</span><br><span class="line">      copy_backward(_M_start._M_node, _M_finish._M_node + 1, </span><br><span class="line">                    __new_nstart + __old_num_nodes);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    //否则，申请新的内存区域了</span><br><span class="line">    size_type __new_map_size = </span><br><span class="line">      _M_map_size + max(_M_map_size, __nodes_to_add) + 2;</span><br><span class="line"></span><br><span class="line">    _Map_pointer __new_map = _M_allocate_map(__new_map_size);</span><br><span class="line">    __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2</span><br><span class="line">                         + (__add_at_front ? __nodes_to_add : 0);</span><br><span class="line">    copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);</span><br><span class="line">    _M_deallocate_map(_M_map, _M_map_size);</span><br><span class="line"></span><br><span class="line">    _M_map = __new_map;</span><br><span class="line">    _M_map_size = __new_map_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _M_start._M_set_node(__new_nstart);</span><br><span class="line">  _M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);</span><br><span class="line">&#125;</span><br><span class="line">//deque比较相等，是比较内部的数据是否相等。其他容器vector,list应该也相应重载了。</span><br><span class="line">template &lt;class _Tp, class _Alloc&gt;</span><br><span class="line">inline bool operator==(const deque&lt;_Tp, _Alloc&gt;&amp; __x,</span><br><span class="line">                       const deque&lt;_Tp, _Alloc&gt;&amp; __y) &#123;</span><br><span class="line">  return __x.size() == __y.size() &amp;&amp;</span><br><span class="line">         equal(__x.begin(), __x.end(), __y.begin());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，deque的<code>erase(), insert()</code>除非在头尾，不然都算O(n)的复杂度，因为要移动其他数据。连续内存块没办法。像List的话，只要有插入或移除的对应的iterator，就是O(1)的复杂度，不过一般要得到这个iterator也得O(n)的复杂度来寻找。</p>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>stack只是普通的容器对接口做了些限制。SGI STL 以deque作为缺省情况下的stack底部结构。stack代码也真是短。接口也少。无法遍历。有一个底部容器的话，分分钟写一个stack。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#ifndef __SGI_STL_INTERNAL_STACK_H</span><br><span class="line">#define __SGI_STL_INTERNAL_STACK_H</span><br><span class="line"></span><br><span class="line">#include &lt;sequence_concepts.h&gt;</span><br><span class="line"></span><br><span class="line">__STL_BEGIN_NAMESPACE</span><br><span class="line"></span><br><span class="line">// Forward declarations of operators == and &lt;, needed for friend declaration.</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, </span><br><span class="line">          class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(deque&lt;_Tp&gt;) &gt;</span><br><span class="line">class stack;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator==(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y);</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator&lt;(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Sequence&gt;</span><br><span class="line">class stack &#123;</span><br><span class="line"></span><br><span class="line">  // requirements:</span><br><span class="line"></span><br><span class="line">  __STL_CLASS_REQUIRES(_Tp, _Assignable);</span><br><span class="line">  __STL_CLASS_REQUIRES(_Sequence, _BackInsertionSequence);</span><br><span class="line">  typedef typename _Sequence::value_type _Sequence_value_type;</span><br><span class="line">  __STL_CLASS_REQUIRES_SAME_TYPE(_Tp, _Sequence_value_type);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef __STL_MEMBER_TEMPLATES</span><br><span class="line">  template &lt;class _Tp1, class _Seq1&gt;</span><br><span class="line">  friend bool operator== (const stack&lt;_Tp1, _Seq1&gt;&amp;,</span><br><span class="line">                          const stack&lt;_Tp1, _Seq1&gt;&amp;);</span><br><span class="line">  template &lt;class _Tp1, class _Seq1&gt;</span><br><span class="line">  friend bool operator&lt; (const stack&lt;_Tp1, _Seq1&gt;&amp;,</span><br><span class="line">                         const stack&lt;_Tp1, _Seq1&gt;&amp;);</span><br><span class="line">#else /* __STL_MEMBER_TEMPLATES */</span><br><span class="line">  friend bool __STD_QUALIFIER</span><br><span class="line">  operator== __STL_NULL_TMPL_ARGS (const stack&amp;, const stack&amp;);</span><br><span class="line">  friend bool __STD_QUALIFIER</span><br><span class="line">  operator&lt; __STL_NULL_TMPL_ARGS (const stack&amp;, const stack&amp;);</span><br><span class="line">#endif /* __STL_MEMBER_TEMPLATES */</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  typedef typename _Sequence::value_type      value_type;</span><br><span class="line">  typedef typename _Sequence::size_type       size_type;</span><br><span class="line">  typedef          _Sequence                  container_type;</span><br><span class="line"></span><br><span class="line">  typedef typename _Sequence::reference       reference;</span><br><span class="line">  typedef typename _Sequence::const_reference const_reference;</span><br><span class="line">protected:</span><br><span class="line">  _Sequence c;</span><br><span class="line">public:</span><br><span class="line">  stack() : c() &#123;&#125;</span><br><span class="line">  explicit stack(const _Sequence&amp; __s) : c(__s) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  bool empty() const &#123; return c.empty(); &#125;</span><br><span class="line">  size_type size() const &#123; return c.size(); &#125;</span><br><span class="line">  reference top() &#123; return c.back(); &#125;</span><br><span class="line">  const_reference top() const &#123; return c.back(); &#125;</span><br><span class="line">  void push(const value_type&amp; __x) &#123; c.push_back(__x); &#125;</span><br><span class="line">  void pop() &#123; c.pop_back(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">//对应容器是否相等</span><br><span class="line">bool operator==(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return __x.c == __y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator&lt;(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return __x.c &lt; __y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator!=(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return !(__x == __y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator&gt;(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return __y &lt; __x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator&lt;=(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return !(__y &lt; __x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator&gt;=(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return !(__x &lt; __y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */</span><br><span class="line"></span><br><span class="line">__STL_END_NAMESPACE</span><br><span class="line"></span><br><span class="line">#endif /* __SGI_STL_INTERNAL_STACK_H */</span><br></pre></td></tr></table></figure>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>queue是一种先进先出（FIFO）的数据结构。从底部加入元素，从顶部取出元素。不允许遍历。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//默认用deque做底部容器</span><br><span class="line">template &lt;class _Tp, </span><br><span class="line">          class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(deque&lt;_Tp&gt;) &gt;</span><br><span class="line">class queue;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Sequence&gt;</span><br><span class="line">class queue &#123;</span><br><span class="line"></span><br><span class="line">  // requirements:</span><br><span class="line"></span><br><span class="line">  __STL_CLASS_REQUIRES(_Tp, _Assignable);</span><br><span class="line">  __STL_CLASS_REQUIRES(_Sequence, _FrontInsertionSequence);</span><br><span class="line">  __STL_CLASS_REQUIRES(_Sequence, _BackInsertionSequence);</span><br><span class="line">  typedef typename _Sequence::value_type _Sequence_value_type;</span><br><span class="line">  __STL_CLASS_REQUIRES_SAME_TYPE(_Tp, _Sequence_value_type);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef __STL_MEMBER_TEMPLATES </span><br><span class="line">  template &lt;class _Tp1, class _Seq1&gt;</span><br><span class="line">  friend bool operator== (const queue&lt;_Tp1, _Seq1&gt;&amp;,</span><br><span class="line">                          const queue&lt;_Tp1, _Seq1&gt;&amp;);</span><br><span class="line">  template &lt;class _Tp1, class _Seq1&gt;</span><br><span class="line">  friend bool operator&lt; (const queue&lt;_Tp1, _Seq1&gt;&amp;,</span><br><span class="line">                         const queue&lt;_Tp1, _Seq1&gt;&amp;);</span><br><span class="line">#else /* __STL_MEMBER_TEMPLATES */</span><br><span class="line">  //对应的容器是否相同(重载过==操作)。</span><br><span class="line">  friend bool __STD_QUALIFIER</span><br><span class="line">  operator== __STL_NULL_TMPL_ARGS (const queue&amp;, const queue&amp;);</span><br><span class="line">  friend bool __STD_QUALIFIER</span><br><span class="line">  operator&lt;  __STL_NULL_TMPL_ARGS (const queue&amp;, const queue&amp;);</span><br><span class="line">#endif /* __STL_MEMBER_TEMPLATES */</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  typedef typename _Sequence::value_type      value_type;</span><br><span class="line">  typedef typename _Sequence::size_type       size_type;</span><br><span class="line">  typedef          _Sequence                  container_type;</span><br><span class="line"></span><br><span class="line">  typedef typename _Sequence::reference       reference;</span><br><span class="line">  typedef typename _Sequence::const_reference const_reference;</span><br><span class="line">protected:</span><br><span class="line">  _Sequence c;</span><br><span class="line">public:</span><br><span class="line">  //对外只有这几个接口。front, back, push, pop</span><br><span class="line">  queue() : c() &#123;&#125;</span><br><span class="line">  explicit queue(const _Sequence&amp; __c) : c(__c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  bool empty() const &#123; return c.empty(); &#125;</span><br><span class="line">  size_type size() const &#123; return c.size(); &#125;</span><br><span class="line">  reference front() &#123; return c.front(); &#125;</span><br><span class="line">  const_reference front() const &#123; return c.front(); &#125;</span><br><span class="line">  reference back() &#123; return c.back(); &#125;</span><br><span class="line">  const_reference back() const &#123; return c.back(); &#125;</span><br><span class="line">  void push(const value_type&amp; __x) &#123; c.push_back(__x); &#125;</span><br><span class="line">  void pop() &#123; c.pop_front(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p>heap是对应的一些堆算法，不指定特殊容器。priority_queue用其进行实现和维护。底部还是需要其他容器支持。</p>
<p>警告：堆排序是不稳定的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//push_heap 对应的代码结构，从底部往上找，知道找到该点，其parent的value大于该value</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Distance, <span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__push_heap(_RandomAccessIterator __first,</span><br><span class="line">            _Distance __holeIndex, _Distance __topIndex, _Tp __value)</span><br><span class="line">&#123;</span><br><span class="line">  _Distance __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (__holeIndex &gt; __topIndex &amp;&amp; *(__first + __parent) &lt; __value) &#123;</span><br><span class="line">    <span class="comment">//将value下移至子节点</span></span><br><span class="line">    *(__first + __holeIndex) = *(__first + __parent);</span><br><span class="line">    __holeIndex = __parent;</span><br><span class="line">    __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  &#125;    </span><br><span class="line">  *(__first + __holeIndex) = __value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Distance, <span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">__push_heap_aux(_RandomAccessIterator __first,</span><br><span class="line">                _RandomAccessIterator __last, _Distance*, _Tp*)</span><br><span class="line">&#123;</span><br><span class="line">  __push_heap(__first, _Distance((__last - __first) - <span class="number">1</span>), _Distance(<span class="number">0</span>), </span><br><span class="line">              _Tp(*(__last - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line"><span class="title">push_heap</span><span class="params">(_RandomAccessIterator __first, _RandomAccessIterator __last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __push_heap_aux(__first, __last,</span><br><span class="line">                  __DISTANCE_TYPE(__first), __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pop_heap对应的代码</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Distance, <span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,</span><br><span class="line">              _Distance __len, _Tp __value)</span><br><span class="line">&#123;</span><br><span class="line">  _Distance __topIndex = __holeIndex;</span><br><span class="line">  _Distance __secondChild = <span class="number">2</span> * __holeIndex + <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//先不断往下走走走，走到叶子节点。将左右子节点较大值放入parent，然后转到该较大子节点处。循环。</span></span><br><span class="line">  <span class="keyword">while</span> (__secondChild &lt; __len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*(__first + __secondChild) &lt; *(__first + (__secondChild - <span class="number">1</span>)))</span><br><span class="line">      __secondChild--;</span><br><span class="line">    *(__first + __holeIndex) = *(__first + __secondChild);</span><br><span class="line">    __holeIndex = __secondChild;</span><br><span class="line">    __secondChild = <span class="number">2</span> * (__secondChild + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (__secondChild == __len) &#123;</span><br><span class="line">    *(__first + __holeIndex) = *(__first + (__secondChild - <span class="number">1</span>));</span><br><span class="line">    __holeIndex = __secondChild - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//然后在往上push_heap,把value插进去！目前该叶节点是没有内容的。</span></span><br><span class="line">  __push_heap(__first, __holeIndex, __topIndex, __value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Distance&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">           _RandomAccessIterator __result, _Tp __value, _Distance*)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//先把最大值移到末尾处</span></span><br><span class="line">  *__result = *__first;</span><br><span class="line">  <span class="comment">//然后调整heap，插入原本处在末尾的value</span></span><br><span class="line">  __adjust_heap(__first, _Distance(<span class="number">0</span>), _Distance(__last - __first), __value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">__pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">               _Tp*)</span><br><span class="line">&#123;</span><br><span class="line">  __pop_heap(__first, __last - <span class="number">1</span>, __last - <span class="number">1</span>, </span><br><span class="line">             _Tp(*(__last - <span class="number">1</span>)), __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(_RandomAccessIterator __first, </span><br><span class="line">                     _RandomAccessIterator __last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __pop_heap_aux(__first, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不明白为什么pop_heap的时候要先下移至叶节点，然后在进行push_heap。明明直接从上往下的时候就判断什么时候停止然后放入目标value。虽然他们的复杂度一样O(n)，但是差了一倍吧。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sort_heap首先要保证first到last的数据结构是一个合法的heap，然后不断pop最大值到尾部，实现sort</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(_RandomAccessIterator __first, _RandomAccessIterator __last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; <span class="number">1</span>)</span><br><span class="line">    pop_heap(__first, __last--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Distance&gt;</span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__make_heap(_RandomAccessIterator __first,</span><br><span class="line">            _RandomAccessIterator __last, _Tp*, _Distance*)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__last - __first &lt; <span class="number">2</span>) return;</span><br><span class="line">  _Distance __len = __last - __first;</span><br><span class="line">  <span class="comment">//从节点的一半处开始，heap是一个完全二叉树，叶节点从左到右是满的，不会终结空一个出来。</span></span><br><span class="line">  <span class="comment">//也就是这个parent现在没有或刚有子节点（一个2或3个节点的小树）。</span></span><br><span class="line">  _Distance __parent = (__len - <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//就first是iterator类型，parent是distance类型，调整以parent为根的子树。</span></span><br><span class="line">    <span class="comment">//然后parent--,不断增大子树范围，最终实现一个heap</span></span><br><span class="line">    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)));</span><br><span class="line">    <span class="keyword">if</span> (__parent == <span class="number">0</span>) return;</span><br><span class="line">    __parent--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line"><span class="title">make_heap</span><span class="params">(_RandomAccessIterator __first, _RandomAccessIterator __last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __make_heap(__first, __last,</span><br><span class="line">              __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p>优先队列。默认的compare是最大堆。然后底层容器sort()后就是升序。</p>
<p>默认以vector为底部容器。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class _Tp, </span><br><span class="line">          class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(vector&lt;_Tp&gt;),</span><br><span class="line">          class _Compare</span><br><span class="line">            //默认的compare是less</span><br><span class="line">          __STL_DEPENDENT_DEFAULT_TMPL(less&lt;typename _Sequence::value_type&gt;) &gt;</span><br><span class="line">class priority_queue &#123;</span><br><span class="line"> </span><br><span class="line">protected:</span><br><span class="line">  //一个底部容器，一个compare</span><br><span class="line">  _Sequence c;</span><br><span class="line">  _Compare comp;</span><br><span class="line">public:</span><br><span class="line">  priority_queue() : c() &#123;&#125;</span><br><span class="line">  explicit priority_queue(const _Compare&amp; __x) :  c(), comp(__x) &#123;&#125;</span><br><span class="line">  priority_queue(const _Compare&amp; __x, const _Sequence&amp; __s) </span><br><span class="line">    : c(__s), comp(__x) </span><br><span class="line">    &#123; make_heap(c.begin(), c.end(), comp); &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;class _InputIterator&gt;</span><br><span class="line">  priority_queue(_InputIterator __first, _InputIterator __last) </span><br><span class="line">    : c(__first, __last) &#123; make_heap(c.begin(), c.end(), comp); &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;class _InputIterator&gt;</span><br><span class="line">  priority_queue(_InputIterator __first, </span><br><span class="line">                 _InputIterator __last, const _Compare&amp; __x)</span><br><span class="line">    : c(__first, __last), comp(__x) </span><br><span class="line">    &#123; make_heap(c.begin(), c.end(), comp); &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;class _InputIterator&gt;</span><br><span class="line">  priority_queue(_InputIterator __first, _InputIterator __last,</span><br><span class="line">                 const _Compare&amp; __x, const _Sequence&amp; __s)</span><br><span class="line">  : c(__s), comp(__x)</span><br><span class="line">  &#123; </span><br><span class="line">    c.insert(c.end(), __first, __last);</span><br><span class="line">    make_heap(c.begin(), c.end(), comp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool empty() const &#123; return c.empty(); &#125;</span><br><span class="line">  size_type size() const &#123; return c.size(); &#125;</span><br><span class="line">  const_reference top() const &#123; return c.front(); &#125;</span><br><span class="line">  void push(const value_type&amp; __x) &#123;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      c.push_back(__x); //先把数据push_back到尾部，再调整堆。</span><br><span class="line">      push_heap(c.begin(), c.end(), comp);</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(c.clear());</span><br><span class="line">  &#125;</span><br><span class="line">  void pop() &#123;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      pop_heap(c.begin(), c.end(), comp);//先pop_heap</span><br><span class="line">      c.pop_back();再pop出尾部数据</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(c.clear());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="slist"><a href="#slist" class="headerlink" title="slist"></a>slist</h2><p>SGI STL提供的单向链表（single linked list）。不在标准规格之内。</p>
<p>由于是单向链表，所以只能在iterator之后插入、移除才是高效的。</p>
<p>slist特别提供了<code>insert_after(),erase_after()</code>供使用。同时，只提供<code>push_front()</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _Slist_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//指针</span></span><br><span class="line">  _Slist_node_base* _M_next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> _Slist_node : <span class="keyword">public</span> _Slist_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//具体数据</span></span><br><span class="line">  _Tp _M_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _Slist_iterator_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span>               size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>            difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> forward_iterator_tag iterator_category;</span><br><span class="line"></span><br><span class="line">  _Slist_node_base* _M_node;</span><br><span class="line"></span><br><span class="line">  _Slist_iterator_base(_Slist_node_base* __x) : _M_node(__x) &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> _M_incr() &#123; _M_node = _M_node-&gt;_M_next; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(const _Slist_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</span><br><span class="line">    return _M_node == __x._M_node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(const _Slist_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</span><br><span class="line">    return _M_node != __x._M_node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Ref, <span class="keyword">class</span> _Ptr&gt;</span><br><span class="line"><span class="keyword">struct</span> _Slist_iterator : <span class="keyword">public</span> _Slist_iterator_base</span><br><span class="line">&#123;</span><br><span class="line">  _Slist_iterator(_Node* __x) : _Slist_iterator_base(__x) &#123;&#125;</span><br><span class="line">  _Slist_iterator() : _Slist_iterator_base(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  _Slist_iterator(<span class="keyword">const</span> iterator&amp; __x) : _Slist_iterator_base(__x._M_node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; return ((_Node*) _M_node)-&gt;_M_data; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; return &amp;(operator*()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">  &#123;</span><br><span class="line">    _M_incr();</span><br><span class="line">    return *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    _M_incr();</span><br><span class="line">    return __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Alloc&gt; </span><br><span class="line"><span class="keyword">struct</span> _Slist_base &#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Alloc allocator_type;</span><br><span class="line">  <span class="function">allocator_type <span class="title">get_allocator</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; return allocator_type(); &#125;</span><br><span class="line"></span><br><span class="line">  _Slist_base(<span class="keyword">const</span> allocator_type&amp;) &#123; _M_head._M_next = <span class="number">0</span>; &#125;</span><br><span class="line">  ~_Slist_base() &#123; _M_erase_after(&amp;_M_head, <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;_Slist_node&lt;_Tp&gt;, _Alloc&gt; _Alloc_type;</span><br><span class="line">  _Slist_node&lt;_Tp&gt;* _M_get_node() &#123; return _Alloc_type::allocate(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="keyword">void</span> _M_put_node(_Slist_node&lt;_Tp&gt;* __p) &#123; _Alloc_type::deallocate(__p, <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  _Slist_node_base* _M_erase_after(_Slist_node_base* __pos)</span><br><span class="line">  &#123;</span><br><span class="line">    _Slist_node&lt;_Tp&gt;* __next = (_Slist_node&lt;_Tp&gt;*) (__pos-&gt;_M_next);</span><br><span class="line">    _Slist_node_base* __next_next = __next-&gt;_M_next;</span><br><span class="line">    __pos-&gt;_M_next = __next_next;</span><br><span class="line">    destroy(&amp;__next-&gt;_M_data);</span><br><span class="line">    _M_put_node(__next);</span><br><span class="line">    return __next_next;</span><br><span class="line">  &#125;</span><br><span class="line">  _Slist_node_base* _M_erase_after(_Slist_node_base*, _Slist_node_base*);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">//空的node当head</span></span><br><span class="line">  _Slist_node_base _M_head;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class="line"><span class="keyword">class</span> slist : <span class="keyword">private</span> _Slist_base&lt;_Tp,_Alloc&gt;&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也不在意多一个prev的指针，一般还是用list的好。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/28/STL-3/" data-id="ciofwrhd3000a21nqldff9704" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-STL/">C++ STL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-STL-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/19/STL-2/" class="article-date">
  <time datetime="2016-04-19T03:21:34.000Z" itemprop="datePublished">2016-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/19/STL-2/">STL源码剖析（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="4-sequence-containers"><a href="#4-sequence-containers" class="headerlink" title="4 sequence containers"></a>4 sequence containers</h1><p>常用的数据结构不外乎<code>array, list, tree, stack, queue, hash table,  set, map</code>等等， 数据结构可分为序列式(sequence)和关联式(associative)两种。</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector本身比较简单，将array抽象了一下，能够自动分配内存大小，内部存储数据的还是一个连续空间的数组类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要是如下三个属性</span></span><br><span class="line">_Tp* _M_start;</span><br><span class="line">_Tp* _M_finish;</span><br><span class="line">_Tp* _M_end_of_storage;</span><br><span class="line"><span class="comment">//然后vector相应型别定义</span></span><br></pre></td></tr></table></figure>
<p>可以随机读取、删除，<code>push_bach(),pop_back()</code>是O(1）复杂度，但是<code>insert(),earse()</code>就是O(n)的复杂度，因为要移动数组。</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>STL 的List是一个环状双向链表，且有一个空节点在链表末尾（就是List.end()指向的节点，end()一般指向最后一个节点的下一个节点），然后该空节点指向头结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list node的结构</span></span><br><span class="line"><span class="keyword">struct</span> _List_node_base &#123;</span><br><span class="line">  _List_node_base* _M_next;</span><br><span class="line">  _List_node_base* _M_prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> _List_node : <span class="keyword">public</span> _List_node_base &#123;</span><br><span class="line">  _Tp _M_data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// iterator </span></span><br><span class="line"><span class="keyword">struct</span> _List_iterator_base &#123;</span><br><span class="line">  <span class="comment">// tag是个双向的iterator</span></span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">  <span class="comment">// 主要为一个指向node的指针</span></span><br><span class="line">  _List_node_base* _M_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>List因为是链表结构，所以每次申请空间可以只申请一个，<code>push_back(), push_front(), insert(iterator，value)</code>都是O(1)的复杂度。</p>
<p><code>unique()</code>只删除连续出现的相同的元素，因在<code>sort()</code>之后使用，<code>remove(value)</code>删除所有相同元素，而不是第一个。</p>
<p>list的<code>sort()</code>采用自定义的<code>sort()</code>函数，STL源码剖析中说是采用的<del>~quick sort</del>~，其实应该是merge sort，看了很久才理解。<a href="http://blog.csdn.net/lijun5635/article/details/23963707" target="_blank" rel="external">该处</a>举了个例子，讲的比较清楚。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;_Tp, _Alloc&gt;::sort()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Do nothing if the list has length 0 or 1.</span></span><br><span class="line">  <span class="keyword">if</span> (_M_node-&gt;_M_next != _M_node &amp;&amp; _M_node-&gt;_M_next-&gt;_M_next != _M_node) &#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;_Tp, _Alloc&gt; __carry;</span><br><span class="line">    <span class="comment">//用来存放以排好序的List数组</span></span><br><span class="line">    <span class="built_in">list</span>&lt;_Tp, _Alloc&gt; __counter[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> __fill = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!empty()) &#123;</span><br><span class="line">      <span class="comment">/*先1、2排序，放入counter[1],然后3，4排序，再跟counter[1]进行merge，放入counter[2]，完成1、2、3、4排序。然后在5、6、7、8排序，再跟contour[2]merge等等.所以counter[64]可以最多2^64个数据.*/</span></span><br><span class="line">      __carry.splice(__carry.begin(), *<span class="keyword">this</span>, begin());</span><br><span class="line">      <span class="keyword">int</span> __i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(__i &lt; __fill &amp;&amp; !__counter[__i].empty()) &#123;</span><br><span class="line">        __counter[__i].merge(__carry);</span><br><span class="line">        __carry.swap(__counter[__i++]);</span><br><span class="line">      &#125;</span><br><span class="line">      __carry.swap(__counter[__i]);         </span><br><span class="line">      <span class="keyword">if</span> (__i == __fill) ++__fill;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> __i = <span class="number">1</span>; __i &lt; __fill; ++__i)</span><br><span class="line">      __counter[__i].merge(__counter[__i<span class="number">-1</span>]);</span><br><span class="line">    swap(__counter[__fill<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/19/STL-2/" data-id="ciofwrhcl000121nq06poa7ru" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-STL/">C++ STL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-STL-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/15/STL-1/" class="article-date">
  <time datetime="2016-04-15T12:57:49.000Z" itemprop="datePublished">2016-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/15/STL-1/">STL源码剖析（1）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-9-一些C-语法"><a href="#1-9-一些C-语法" class="headerlink" title="1.9 一些C++语法"></a>1.9 一些C++语法</h2><h3 id="1-9-2-临时对象的产生于运用"><a href="#1-9-2-临时对象的产生于运用" class="headerlink" title="1.9.2 临时对象的产生于运用"></a>1.9.2 临时对象的产生于运用</h3><p>通过临时对象，简化程序。在类型名称之后直接加小括号，并制定初值，e.g.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shape(<span class="number">3</span>,<span class="number">5</span>), <span class="keyword">int</span>(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p>STL 最常将此技巧应用于仿函数（Functor)于算法的搭配上。</p>
<p>PS：Functor 还没细看。</p>
<h3 id="1-9-3-静态常量证书成员在class内部直接初始化"><a href="#1-9-3-静态常量证书成员在class内部直接初始化" class="headerlink" title="1.9.3 静态常量证书成员在class内部直接初始化"></a>1.9.3 静态常量证书成员在class内部直接初始化</h3><p>const static <em>integral</em> data member </p>
<p><em>integral</em> 泛指所有整数型别：int, long, char 等</p>
<h2 id="2-allocator"><a href="#2-allocator" class="headerlink" title="2 allocator"></a>2 allocator</h2><ul>
<li><p>设置sub-allocation, 两层结构，分别对应大内存和小内存的申请空间</p>
</li>
<li><p>小内存设置free lists。结构为union,节省内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> obj &#123;</span><br><span class="line">  <span class="keyword">union</span> obj * free_list_link;</span><br><span class="line">  <span class="keyword">char</span> client_data[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>并设置区块的对齐（<code>round_up(size_t bytes)</code>），比如都是8的倍数，（如30bytes的，自动调整为32bytes），标准化内存申请，可重复性高。</p>
</li>
<li><p>free lists某个块区的list用完了，通过<code>chunk_alloc()</code>,首先向内存池(memory pool)申请，实在没有了，可以用free lists中更大的块区，分配给它。</p>
</li>
<li><p><code>ctor(), dtor(), copy(), fill(), fill_n()</code>等，都可以根据情况，选择更高效的填充方法。看它的<code>is_POD_type</code>等是否是trivial的，第三章有具体讲。</p>
</li>
<li><p>通过traits（只要还是重载，参数不同，还可以实现特化版本）对应不同的具体实现。</p>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> T&gt;</span><br><span class="line">  <span class="function">Function <span class="title">find</span><span class="params">(InputIterator first, InputIterator last, <span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first != last &amp;&amp; *first != value) ++first;</span><br><span class="line">  return first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> Function&gt;</span><br><span class="line">  <span class="function">Function <span class="title">for_each</span><span class="params">(InputIterator first, InputIterator last, Function f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">    f(*first);</span><br><span class="line">  return f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数写的挺帅的。</p>
<h2 id="3-iterators-and-traits"><a href="#3-iterators-and-traits" class="headerlink" title="3 iterators and traits"></a>3 iterators and traits</h2><p>STL中心思想：将数据容器（containers）和算法（algorithms）分开，彼此独立设计，最后再将他们撮合在一起。（适配器？）</p>
<p>iterator 可看做是一种smart pointer。基本上要提供<code>operator*, operator-&gt;,operator++,operator--</code>等。</p>
<h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><p>auto_ptr是一个用来包装原生指针的对象，析构函数会自动delete掉内存。</p>
<p>在<code>&lt;memory&gt;</code>内</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class _Tp&gt; class auto_ptr &#123;</span><br><span class="line">private:</span><br><span class="line">  _Tp* _M_ptr;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  typedef _Tp element_type;</span><br><span class="line">//无法隐式转换，无法auto_ptr p1 = p2；</span><br><span class="line">  explicit auto_ptr(_Tp* __p = 0) __STL_NOTHROW : _M_ptr(__p) &#123;&#125;</span><br><span class="line">  auto_ptr(auto_ptr&amp; __a) __STL_NOTHROW : _M_ptr(__a.release()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">#ifdef __STL_MEMBER_TEMPLATES</span><br><span class="line">  template &lt;class _Tp1&gt; auto_ptr(auto_ptr&lt;_Tp1&gt;&amp; __a) __STL_NOTHROW</span><br><span class="line">    : _M_ptr(__a.release()) &#123;&#125;</span><br><span class="line">#endif /* __STL_MEMBER_TEMPLATES */</span><br><span class="line">//在赋值时，原有指针释放。</span><br><span class="line">  auto_ptr&amp; operator=(auto_ptr&amp; __a) __STL_NOTHROW &#123;</span><br><span class="line">    if (&amp;__a != this) &#123;</span><br><span class="line">      delete _M_ptr;</span><br><span class="line">      _M_ptr = __a.release();</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">#ifdef __STL_MEMBER_TEMPLATES</span><br><span class="line">  template &lt;class _Tp1&gt;</span><br><span class="line">  auto_ptr&amp; operator=(auto_ptr&lt;_Tp1&gt;&amp; __a) __STL_NOTHROW &#123;</span><br><span class="line">    if (__a.get() != this-&gt;get()) &#123;</span><br><span class="line">      delete _M_ptr;</span><br><span class="line">      _M_ptr = __a.release();</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line">#endif /* __STL_MEMBER_TEMPLATES */</span><br><span class="line"></span><br><span class="line">  // Note: The C++ standard says there is supposed to be an empty throw</span><br><span class="line">  // specification here, but omitting it is standard conforming.  Its </span><br><span class="line">  // presence can be detected only if _Tp::~_Tp() throws, but (17.4.3.6/2)</span><br><span class="line">  // this is prohibited.</span><br><span class="line">  ~auto_ptr() &#123; delete _M_ptr; &#125;</span><br><span class="line"></span><br><span class="line">  _Tp&amp; operator*() const __STL_NOTHROW &#123;</span><br><span class="line">    return *_M_ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  _Tp* operator-&gt;() const __STL_NOTHROW &#123;</span><br><span class="line">    return _M_ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  _Tp* get() const __STL_NOTHROW &#123;</span><br><span class="line">    return _M_ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  //释放该所有权，将指针返回</span><br><span class="line">  _Tp* release() __STL_NOTHROW &#123;</span><br><span class="line">    _Tp* __tmp = _M_ptr;</span><br><span class="line">    _M_ptr = 0;</span><br><span class="line">    return __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  //重新赋值，原有对象释放</span><br><span class="line">  void reset(_Tp* __p = 0) __STL_NOTHROW &#123;</span><br><span class="line">    if (__p != _M_ptr) &#123;</span><br><span class="line">      delete _M_ptr;</span><br><span class="line">      _M_ptr = __p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // According to the C++ standard, these conversions are required.  Most</span><br><span class="line">  // present-day compilers, however, do not enforce that requirement---and, </span><br><span class="line">  // in fact, most present-day compilers do not support the language </span><br><span class="line">  // features that these conversions rely on.</span><br><span class="line">  </span><br><span class="line">#if defined(__SGI_STL_USE_AUTO_PTR_CONVERSIONS) &amp;&amp; \</span><br><span class="line">    defined(__STL_MEMBER_TEMPLATES)</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  auto_ptr(auto_ptr_ref&lt;_Tp&gt; __ref) __STL_NOTHROW</span><br><span class="line">    : _M_ptr(__ref._M_ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  auto_ptr&amp; operator=(auto_ptr_ref&lt;_Tp&gt; __ref) __STL_NOTHROW &#123;</span><br><span class="line">    if (__ref._M_ptr != this-&gt;get()) &#123;</span><br><span class="line">      delete _M_ptr;</span><br><span class="line">      _M_ptr = __ref._M_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;class _Tp1&gt; operator auto_ptr_ref&lt;_Tp1&gt;() __STL_NOTHROW </span><br><span class="line">    &#123; return auto_ptr_ref&lt;_Tp1&gt;(this-&gt;release()); &#125;</span><br><span class="line">  template &lt;class _Tp1&gt; operator auto_ptr&lt;_Tp1&gt;() __STL_NOTHROW</span><br><span class="line">    &#123; return auto_ptr&lt;_Tp1&gt;(this-&gt;release()); &#125;</span><br><span class="line"></span><br><span class="line">#endif /* auto ptr conversions &amp;&amp; member templates */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>auto_ptr指向的内存是独占性的，当它赋值给另一个auto_ptr时，其自身就不再指向该内存区域了，所以最好只在初始化阶段赋值，使用阶段并不将其赋给其他对象。</p>
<blockquote>
<p>auto_ptr适合用来管理生命周期比较短或者不会被远距离传递的动态对象，使用auto_ptr来管理动态分配对象，最好是局限于某个函数内部或者是某个类的内部。也就是说，动态对象的产生，使用和销毁的全过程是处于一个小的受控的范围，而不会在其中加入一些适应未来时态的扩展。</p>
</blockquote>
<p>STL 源码剖析中，特意说明了auto_ptr的存在，但是没讲清楚其独占的特性，简化版中<code>release()，reset()</code>的实现没写，感觉比较坑。</p>
<h3 id="3-4-Traits"><a href="#3-4-Traits" class="headerlink" title="3.4 Traits"></a>3.4 Traits</h3><p>首先，通过参数推导机制，我们可以得到迭代器及其指向数据（其指向数据类型需要在子函数中用模板得到）的类型，但是（所以）无法用于函数的返回值。</p>
<p>以vector为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in &lt;stl_vector.h&gt;</span></span><br><span class="line">  <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line"><span class="comment">// iterator 就是value_type*的，</span></span><br><span class="line">  <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base::allocator_type allocator_type;</span><br><span class="line"><span class="comment">//使用时将iterator赋给相应的iterator类，来完成具体工作</span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator;</span><br></pre></td></tr></table></figure>
<p>其中定义了其数据的各种类型,内部没有定义iterator catagoly，只是需要时直接使用，在Iterator中有。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _InputIterator&gt;</span><br><span class="line"><span class="keyword">void</span> _M_range_insert(iterator __pos,</span><br><span class="line">                     _InputIterator __first, _InputIterator __last,</span><br><span class="line">                     input_iterator_tag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _ForwardIterator&gt;</span><br><span class="line"><span class="keyword">void</span> _M_range_insert(iterator __pos,</span><br><span class="line">                     _ForwardIterator __first, _ForwardIterator __last,</span><br><span class="line">                     forward_iterator_tag);</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//in &lt;stl_iterator.h&gt;</span><br><span class="line">template &lt;class _Container&gt;</span><br><span class="line">//还有 front_insert_iterator, intert_iterator等好多。</span><br><span class="line">class back_insert_iterator &#123;</span><br><span class="line">protected:</span><br><span class="line">  _Container* container;</span><br><span class="line">public:</span><br><span class="line">  typedef _Container          container_type;</span><br><span class="line">  typedef output_iterator_tag iterator_category;</span><br><span class="line">  typedef void                value_type;</span><br><span class="line">  typedef void                difference_type;</span><br><span class="line">  typedef void                pointer;</span><br><span class="line">  typedef void                reference;</span><br><span class="line"></span><br><span class="line">  explicit back_insert_iterator(_Container&amp; __x) : container(&amp;__x) &#123;&#125;</span><br><span class="line">  back_insert_iterator&lt;_Container&gt;&amp;</span><br><span class="line">  operator=(const typename _Container::value_type&amp; __value) &#123; </span><br><span class="line">    container-&gt;push_back(__value);</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line">  back_insert_iterator&lt;_Container&gt;&amp; operator*() &#123; return *this; &#125;</span><br><span class="line">  back_insert_iterator&lt;_Container&gt;&amp; operator++() &#123; return *this; &#125;</span><br><span class="line">  back_insert_iterator&lt;_Container&gt;&amp; operator++(int) &#123; return *this; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class _Iterator&gt;</span><br><span class="line">class reverse_iterator </span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">  _Iterator current;</span><br><span class="line">public:</span><br><span class="line">  typedef typename iterator_traits&lt;_Iterator&gt;::iterator_category</span><br><span class="line">          iterator_category;</span><br><span class="line">  typedef typename iterator_traits&lt;_Iterator&gt;::value_type</span><br><span class="line">          value_type;</span><br><span class="line">  typedef typename iterator_traits&lt;_Iterator&gt;::difference_type</span><br><span class="line">          difference_type;</span><br><span class="line">  typedef typename iterator_traits&lt;_Iterator&gt;::pointer</span><br><span class="line">          pointer;</span><br><span class="line">  typedef typename iterator_traits&lt;_Iterator&gt;::reference</span><br><span class="line">          reference;</span><br><span class="line"></span><br><span class="line">  typedef _Iterator iterator_type;</span><br><span class="line">  typedef reverse_iterator&lt;_Iterator&gt; _Self;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in &lt;stl_iterator_base.h&gt;</span></span><br><span class="line"><span class="keyword">struct</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> output_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> forward_iterator_tag : <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> bidirectional_iterator_tag : <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> random_access_iterator_tag : <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Distance&gt; <span class="keyword">struct</span> input_iterator &#123;</span><br><span class="line">  <span class="keyword">typedef</span> input_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp                value_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Distance          difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp*               pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp&amp;               reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Iterator&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator_traits &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::iterator_category iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::value_type        value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::difference_type   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::pointer           pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::reference         reference;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>最基本的iterator直接使用value type*完成，比如reverse_iterator就使用对应的类简化。</p>
<h3 id="type-traits"><a href="#type-traits" class="headerlink" title="__type_traits"></a>__type_traits</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;type_traits.h&gt;</span></span><br><span class="line"><span class="keyword">struct</span> __true_type &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __false_type &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> __type_traits &#123; </span><br><span class="line">   <span class="keyword">typedef</span> __true_type     this_dummy_member_must_be_first;</span><br><span class="line">                   <span class="comment">/* Do not remove this member. It informs a compiler which</span><br><span class="line">                      automatically specializes __type_traits that this</span><br><span class="line">                      __type_traits template is special. It just makes sure that</span><br><span class="line">                      things work if an implementation is using a template</span><br><span class="line">                      called __type_traits for something unrelated. */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* The following restrictions should be observed for the sake of</span><br><span class="line">      compilers which automatically produce type specific specializations </span><br><span class="line">      of this class:</span><br><span class="line">          - You may reorder the members below if you wish</span><br><span class="line">          - You may remove any of the members below if you wish</span><br><span class="line">          - You must not rename members without making the corresponding</span><br><span class="line">            name change in the compiler</span><br><span class="line">          - Members you add will be treated like regular members unless</span><br><span class="line">            you add the appropriate support in the compiler. */</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//对char, bool, int等很多做了特化处理。</span></span><br></pre></td></tr></table></figure>
<p>iterator_traits负责萃取迭代器的特性，__type_traits负责萃取类型的特性（<code>ctor(), copy(), assignment()</code>的时候用到，提高内存复制、赋值的效率。</p>
<p>PS：感觉STL代码写的挺好的，并不是很难看懂。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/15/STL-1/" data-id="ciofwrhcg000021nqfeue2jnh" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-STL/">C++ STL</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Labels</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-STL/">C++ STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图-路径压缩/">图 路径压缩</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-STL/" style="font-size: 20px;">C++ STL</a> <a href="/tags/图-路径压缩/" style="font-size: 10px;">图 路径压缩</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/05/20/formula/">formula</a>
          </li>
        
          <li>
            <a href="/2016/05/20/STL-6/">STL源码剖析（6）</a>
          </li>
        
          <li>
            <a href="/2016/05/18/STL-5/">STL源码剖析（5）</a>
          </li>
        
          <li>
            <a href="/2016/05/16/STL-4/">STL源码剖析（4）</a>
          </li>
        
          <li>
            <a href="/2016/05/02/union-find/">并查集union-find</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 ding4it<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>