<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Ding4it的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Nothing">
<meta property="og:type" content="website">
<meta property="og:title" content="Ding4it的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Ding4it的博客">
<meta property="og:description" content="Nothing">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ding4it的博客">
<meta name="twitter:description" content="Nothing">
  
    <link rel="alternate" href="/atom.xml" title="Ding4it的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ding4it的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-STL-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/16/STL-4/" class="article-date">
  <time datetime="2016-05-16T05:16:04.000Z" itemprop="datePublished">2016-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/16/STL-4/">STL源码剖析（4）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><p>感觉之前代码贴太多了，接下来少放点代码。</p>
<p>标准的STL关联式容器分为set（集合）和map（映射表）两大类，以及其衍生体multiset和multimap。容器的底层机制均已RB-tree红黑树来完成。</p>
<p>set与map的区别主要是set中键和值是一样的，而map对应的key-value并不一样。</p>
<p>multiset与set和multimap和map之间的区别是multi-系列使用的是<code>Insert-equal()</code>，内部允许重复，而set,map使用的是<code>Insert-unique()</code>，内部没有重复。</p>
<h2 id="树型结构"><a href="#树型结构" class="headerlink" title="树型结构"></a>树型结构</h2><p>树是由节点（nodes）和边（edges）构成。整棵树最上端的节点称为根节点。相连节点之中，在上者称为父节点（parent），在下者称为子节点（child）,无子节点这称为叶节点（leaf）。子节点可以存在多个，如果最多只能有2个子节点，即所谓二叉树(binary tree)。</p>
<p>不同子节点如果拥有同一个父节点，则为兄弟节点（siblings）。根节点至任何节点之间有唯一路径（path），路径所经过的边数，称为路径长度（length）。跟节点至任一节点的路径长度，即该节点的深度（depth）。根节点深度为0。某节点至其最深子节点的路径长度，称为该节点的高度（height）。整棵树的高度，以根节点的高度来表示。</p>
<p><strong>二叉搜索树</strong> 可提供对数时间的元素插入和访问。其放置规则是：任何节点的键值一定大于其左子树的每个节点的键值，小于右子树的每一个节点的键值。</p>
<p><strong>平衡二叉搜索树</strong> AVL-Tree， RB-Tree， AA-Tree。没有任何一个节点深度过大。</p>
<p><a href="http://blog.csdn.net/whucyl/article/details/17289841" target="_blank" rel="external"><strong>AVL-Tree</strong></a>  要求任何节点的左右子树高度相差最多1。不平衡的时候通过对子树进行旋转维持整树的平衡。</p>
<p><strong>插入节点时</strong>，插入点至根节点路径上各节点可能改变平衡状态，因此，只要调整其中最深的那个节点，便可使整棵树重新获得平衡。假设平衡被破坏的各节点中最深的一个节点为X，情况分为以下4种：</p>
<ol>
<li>插入点位于X的<strong>左</strong>子节点的<strong>左</strong>子树：左左</li>
<li>插入点位于X的<strong>左</strong>子节点的<strong>右</strong>子树：左右</li>
<li>插入点位于X的<strong>右</strong>子节点的<strong>左</strong>子树：右左</li>
<li>插入点位于X的<strong>右</strong>子节点的<strong>右</strong>子树：右右</li>
</ol>
<p>1，4情况彼此对称，称为外侧插入，采用单旋转操作；</p>
<p>2，3情况彼此对称，称为内侧插入，采用双旋转操作。</p>
<p><strong>删除节点时</strong>，首先找到要删除的节点，如果</p>
<ol>
<li>该节点是叶节点，直接删除；</li>
<li>该节点有左子树不为空，将该节点替换为左子树的最右叶节点；</li>
<li>否则，将该节点替换为右子树的最左节点。</li>
</ol>
<p>然后，从被替换的叶节点开始往上判断，是否不平衡，若不平衡，则旋转平衡。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树（RB-Tree）不仅是一个二叉搜索树，而且必须满足一下特征：</p>
<ol>
<li>每个节点不是红色就是黑色；</li>
<li>根节点为黑色；</li>
<li>如果节点为红色，其子节点必须为黑；</li>
<li>任一节点至NULL（树尾端）的任何路径，所含的黑节点数必须相同。</li>
</ol>
<p>引申：</p>
<ol>
<li>不存在父节点和子节点都为红色；</li>
<li>新增节点时初始颜色为红色（平衡过后可能为黑）；</li>
<li>新增节点之父节点必须为黑色（否则需平衡）；</li>
<li>空节点可视为黑节点。</li>
</ol>
<p>红黑树太繁琐了，不写了。书210页。贴个链接。<a href="http://www.cnblogs.com/fornever/archive/2011/12/02/2270692.html" target="_blank" rel="external">http://www.cnblogs.com/fornever/archive/2011/12/02/2270692.html</a></p>
<p>以下跟SGI STL 的红黑树实现可能不一样。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>若父节点为黑，则不需平衡。</p>
<p>若父节点为红，则看父节点的兄弟节点。且G为黑，GG不定。</p>
<p>设插入节点为X，父节点为P，父节点兄弟节点为S，祖父节点为G，组祖父为GG。</p>
<ol>
<li>若S为黑，且X为外侧插入。先对PG做单旋，然后更改PG颜色。</li>
<li>若S为黑，且X为内侧插入。先PX单旋，改变GX颜色，在对G做一次单旋。</li>
<li>若S为红，P也是红，则直接把G改为红，PS改为黑。然后X为P，P为G，G为GG，S为GG-&gt;right,重新判断。（跟书上不一样，书上没说S为红且为内插的时候的情况）</li>
</ol>
<p>为了方便，避免递归判断的情况，有一个从上到下的程序：沿着插入节点的路径，从上到下，只要X的两个子节点都是红，则X改为红，两个子节点改为黑，然后再插入的叶节点进行一个单或双旋转，这样不会存在递归的问题。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>红黑树的删除是通过找到一个替换节点替换目标节点，然后删除目标节点来实现的。替代节点N至少有一个子节点为NULL。</p>
<ol>
<li>若N为红色，则其为叶节点（否则其子节点就是黑色，与他兄弟节点（NULL）的黑色节点数就不一样了）。直接把N删掉就行。</li>
<li>若N为黑色，且另一子节点M不为NULL，那么M必为红色叶节点，直接把M替换N，然后删除M就行。</li>
<li>若N为黑色，且为叶节点，则删除N后，破坏了平衡树性质4。需要进行相应操作，假设父节点为P，N的<strong>兄弟节点</strong>为S：<ol>
<li>若S为红，则P为黑，PS旋转，并变色。然后重新对N判断。</li>
<li>以下情况S为黑。<ol>
<li>若P为红，S的2个子节点都为黑，则将PS变色，结束。</li>
<li>若P为黑，S的2个子节点都为黑，则S变为红，将N设为P，重新平衡。</li>
<li>P任意色，若N为P的左节点：<ol>
<li>S右节点SR为红，则PS旋转，SR设为黑，P设为黑，S设为P的颜色。结束。</li>
<li>S左节点SL为红，则SL和S旋转，SL设为黑，S设为红，这样就变成了上面情况。</li>
</ol>
</li>
<li>P任意色，若N为P的右节点:<ol>
<li>若S左节点SL为红，则PS旋转，SL为黑，P为黑，S为P颜色，结束。</li>
<li>若S右节点SR为红，则SR和S旋转，SR为黑，S为红，转为上面情况。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>至此，删除节点完成。接下来就看看SGI STL中RB-Tree的代码实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/16/STL-4/" data-id="cio9k9xzm0006fynqrcw4skfu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-STL/">C++ STL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-union-find" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/02/union-find/" class="article-date">
  <time datetime="2016-05-02T12:36:59.000Z" itemprop="datePublished">2016-05-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/02/union-find/">并查集union-find</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>并查集。简单实现及路径压缩。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="comment">// in initial ,the parent = this.</span></span><br><span class="line">    Node parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// find the root node of a</span></span><br><span class="line"><span class="function">Node <span class="title">find</span><span class="params">(Node a)</span> </span>&#123;</span><br><span class="line">    Node tmp = a;</span><br><span class="line">    <span class="comment">// get the root</span></span><br><span class="line">    <span class="keyword">while</span> (tmp.parent != tmp) &#123;</span><br><span class="line">        tmp = tmp.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    Node i = a, j;</span><br><span class="line">    <span class="comment">// compress the route</span></span><br><span class="line">    <span class="keyword">while</span> (i != tmp) &#123;</span><br><span class="line">        j = i.parent;</span><br><span class="line">        i.parent = tmp;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// join two sets into one</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">join</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">    Node pa = find(a);</span><br><span class="line">    Node pb = find(b);</span><br><span class="line">    <span class="keyword">if</span> (pa != pb) &#123;</span><br><span class="line">        pa.parent = pb;</span><br><span class="line">        <span class="comment">// join</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// already in one set</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/02/union-find/" data-id="cio9k9xz50001fynq1n0n1vb6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/图-路径压缩/">图 路径压缩</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-STL-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/28/STL-3/" class="article-date">
  <time datetime="2016-04-28T09:39:49.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/STL-3/">STL源码剖析（3）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>deque 是一种双向开口的“连续”线性空间，即可以在头尾两端分别做元素的插入和删除操作。</p>
<p>外部接口看起来是连续的，内部是多个内存块的组合。近似连续。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Ref, <span class="keyword">class</span> _Ptr&gt;</span><br><span class="line"><span class="keyword">struct</span> _Deque_iterator &#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp, <span class="keyword">const</span> _Tp&amp;, <span class="keyword">const</span> _Tp*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> _S_buffer_size() &#123; return __deque_buf_size(sizeof(_Tp)); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rando access,可以随机访问</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp** _Map_pointer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator _Self;</span><br><span class="line">  <span class="comment">// 一个iterator包含一块缓冲区的信息</span></span><br><span class="line">  <span class="comment">// 指向当前内容</span></span><br><span class="line">  _Tp* _M_cur;</span><br><span class="line">  <span class="comment">// 该缓冲区头部</span></span><br><span class="line">  _Tp* _M_first;</span><br><span class="line">  <span class="comment">// 尾部</span></span><br><span class="line">  _Tp* _M_last;</span><br><span class="line">  <span class="comment">// 指向对应的总的map的节点指针</span></span><br><span class="line">  _Map_pointer _M_node;</span><br><span class="line"></span><br><span class="line">  _Deque_iterator(_Tp* __x, _Map_pointer __y) </span><br><span class="line">    : _M_cur(__x), _M_first(*__y),</span><br><span class="line">      _M_last(*__y + _S_buffer_size()), _M_node(__y) &#123;&#125;</span><br><span class="line">  _Deque_iterator() : _M_cur(<span class="number">0</span>), _M_first(<span class="number">0</span>), _M_last(<span class="number">0</span>), _M_node(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  _Deque_iterator(<span class="keyword">const</span> iterator&amp; __x)</span><br><span class="line">    : _M_cur(__x._M_cur), _M_first(__x._M_first), </span><br><span class="line">      _M_last(__x._M_last), _M_node(__x._M_node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; return *_M_cur; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; return _M_cur; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//随机访问，指针加减虽然不像vector那样方便，但也就简单的计算就可得出。</span></span><br><span class="line">  difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> _Self&amp; __x) <span class="keyword">const</span> &#123;</span><br><span class="line">    return difference_type(_S_buffer_size()) * (_M_node - __x._M_node - <span class="number">1</span>) +</span><br><span class="line">      (_M_cur - _M_first) + (__x._M_last - __x._M_cur);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    ++_M_cur;</span><br><span class="line">    <span class="keyword">if</span> (_M_cur == _M_last) &#123;</span><br><span class="line">      _M_set_node(_M_node + <span class="number">1</span>);</span><br><span class="line">      _M_cur = _M_first;</span><br><span class="line">    &#125;</span><br><span class="line">    return *<span class="keyword">this</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>++(<span class="keyword">int</span>)  &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    return __tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_cur == _M_first) &#123;</span><br><span class="line">      _M_set_node(_M_node - <span class="number">1</span>);</span><br><span class="line">      _M_cur = _M_last;</span><br><span class="line">    &#125;</span><br><span class="line">    --_M_cur;</span><br><span class="line">    return *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    return __tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>+=(difference_type __n)</span><br><span class="line">  &#123;</span><br><span class="line">    difference_type __offset = __n + (_M_cur - _M_first);</span><br><span class="line">    <span class="keyword">if</span> (__offset &gt;= <span class="number">0</span> &amp;&amp; __offset &lt; difference_type(_S_buffer_size()))</span><br><span class="line">      _M_cur += __n;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      difference_type __node_offset =</span><br><span class="line">        __offset &gt; <span class="number">0</span> ? __offset / difference_type(_S_buffer_size())</span><br><span class="line">                   : -difference_type((-__offset - <span class="number">1</span>) / _S_buffer_size()) - <span class="number">1</span>;</span><br><span class="line">      _M_set_node(_M_node + __node_offset);</span><br><span class="line">      _M_cur = _M_first + </span><br><span class="line">        (__offset - __node_offset * difference_type(_S_buffer_size()));</span><br><span class="line">    &#125;</span><br><span class="line">    return *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Self <span class="keyword">operator</span>+(difference_type __n) <span class="keyword">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    return __tmp += __n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>-=(difference_type __n) &#123; return *<span class="keyword">this</span> += -__n; &#125;</span><br><span class="line"> </span><br><span class="line">  _Self <span class="keyword">operator</span>-(difference_type __n) <span class="keyword">const</span> &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    return __tmp -= __n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 随机访问，返回reference形式，可做左值</span></span><br><span class="line">  reference <span class="keyword">operator</span>[](difference_type __n) <span class="keyword">const</span> &#123; return *(*this + __n); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(const _Self&amp; __x) <span class="keyword">const</span> &#123; return _M_cur == __x._M_cur; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(const _Self&amp; __x) <span class="keyword">const</span> &#123; return !(*this == __x); &#125;</span><br><span class="line">  <span class="comment">// 线比较node指针大小，node一样，则比较对应的cur指针</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> _Self&amp; __x) <span class="keyword">const</span> &#123;</span><br><span class="line">    return (_M_node == __x._M_node) ? </span><br><span class="line">      (_M_cur &lt; __x._M_cur) : (_M_node &lt; __x._M_node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> _Self&amp; __x) <span class="keyword">const</span>  &#123; return __x &lt; *<span class="keyword">this</span>; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(const _Self&amp; __x) <span class="keyword">const</span> &#123; return !(__x &lt; *this); &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(const _Self&amp; __x) <span class="keyword">const</span> &#123; return !(*this &lt; __x); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _M_set_node(_Map_pointer __new_node) &#123;</span><br><span class="line">    _M_node = __new_node;</span><br><span class="line">    _M_first = *__new_node;</span><br><span class="line">    _M_last = _M_first + difference_type(_S_buffer_size());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">class</span> _Deque_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp,_Tp&amp;,_Tp*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp,<span class="keyword">const</span> _Tp&amp;,<span class="keyword">const</span> _Tp*&gt; const_iterator;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> _Alloc allocator_type;</span><br><span class="line">  <span class="function">allocator_type <span class="title">get_allocator</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; return allocator_type(); &#125;</span><br><span class="line"></span><br><span class="line">  _Deque_base(<span class="keyword">const</span> allocator_type&amp;, <span class="keyword">size_t</span> __num_elements)</span><br><span class="line">    : _M_map(<span class="number">0</span>), _M_map_size(<span class="number">0</span>),  _M_start(), _M_finish() &#123;</span><br><span class="line">    _M_initialize_map(__num_elements);</span><br><span class="line">  &#125;</span><br><span class="line">  _Deque_base(<span class="keyword">const</span> allocator_type&amp;)</span><br><span class="line">    : _M_map(<span class="number">0</span>), _M_map_size(<span class="number">0</span>),  _M_start(), _M_finish() &#123;&#125;</span><br><span class="line">  ~_Deque_base();    </span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">void</span> _M_initialize_map(<span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">void</span> _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);</span><br><span class="line">  <span class="keyword">void</span> _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);</span><br><span class="line">  <span class="comment">// 默认的map大小为8快，当然，map节点对应的区域没有初始化，需要再初始化</span></span><br><span class="line">  <span class="keyword">enum</span> &#123; _S_initial_map_size = <span class="number">8</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  _Tp** _M_map;</span><br><span class="line">  <span class="keyword">size_t</span> _M_map_size;</span><br><span class="line">  <span class="comment">// 指向对应的缓冲区buffer</span></span><br><span class="line">  iterator _M_start;</span><br><span class="line">  iterator _M_finish;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;_Tp, _Alloc&gt;  _Node_alloc_type;</span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;_Tp*, _Alloc&gt; _Map_alloc_type;</span><br><span class="line"></span><br><span class="line">  _Tp* _M_allocate_node()</span><br><span class="line">    &#123; return _Node_alloc_type::allocate(__deque_buf_size(sizeof(_Tp))); &#125;</span><br><span class="line">  <span class="keyword">void</span> _M_deallocate_node(_Tp* __p)</span><br><span class="line">    &#123; _Node_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp))); &#125;</span><br><span class="line">  _Tp** _M_allocate_map(<span class="keyword">size_t</span> __n) </span><br><span class="line">    &#123; return _Map_alloc_type::allocate(__n); &#125;</span><br><span class="line">  <span class="keyword">void</span> _M_deallocate_map(_Tp** __p, <span class="keyword">size_t</span> __n) </span><br><span class="line">    &#123; _Map_alloc_type::deallocate(__p, __n); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// num_elements=0的时候，也会先分配一个缓冲区出来</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_Deque_base&lt;_Tp,_Alloc&gt;::_M_initialize_map(<span class="keyword">size_t</span> __num_elements)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">size_t</span> __num_nodes = </span><br><span class="line">    __num_elements / __deque_buf_size(sizeof(_Tp)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  _M_map_size = max((<span class="keyword">size_t</span>) _S_initial_map_size, __num_nodes + <span class="number">2</span>);</span><br><span class="line">  _M_map = _M_allocate_map(_M_map_size);</span><br><span class="line"></span><br><span class="line">  _Tp** __nstart = _M_map + (_M_map_size - __num_nodes) / <span class="number">2</span>;</span><br><span class="line">  _Tp** __nfinish = __nstart + __num_nodes;</span><br><span class="line">    </span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    _M_create_nodes(__nstart, __nfinish);</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND((_M_deallocate_map(_M_map, _M_map_size), </span><br><span class="line">                _M_map = <span class="number">0</span>, _M_map_size = <span class="number">0</span>));</span><br><span class="line">  _M_start._M_set_node(__nstart);</span><br><span class="line">  _M_finish._M_set_node(__nfinish - <span class="number">1</span>);</span><br><span class="line">  _M_start._M_cur = _M_start._M_first;</span><br><span class="line">  _M_finish._M_cur = _M_finish._M_first +</span><br><span class="line">               __num_elements % __deque_buf_size(sizeof(_Tp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class="line">class deque : protected _Deque_base&lt;_Tp, _Alloc&gt; &#123;</span><br><span class="line">public:                         // Constructor, destructor.</span><br><span class="line">  // 初始化_Base的时候都会带上大小。</span><br><span class="line">  explicit deque(const allocator_type&amp; __a = allocator_type()) </span><br><span class="line">    : _Base(__a, 0) &#123;&#125;</span><br><span class="line">  deque(const deque&amp; __x) : _Base(__x.get_allocator(), __x.size()) </span><br><span class="line">    &#123; uninitialized_copy(__x.begin(), __x.end(), _M_start); &#125;</span><br><span class="line">  deque(size_type __n, const value_type&amp; __value,</span><br><span class="line">        const allocator_type&amp; __a = allocator_type()) : _Base(__a, __n)</span><br><span class="line">    &#123; _M_fill_initialize(__value); &#125;</span><br><span class="line">  explicit deque(size_type __n) : _Base(allocator_type(), __n)</span><br><span class="line">    &#123; _M_fill_initialize(value_type()); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Alloc&gt;</span><br><span class="line">void deque&lt;_Tp,_Alloc&gt;::_M_reallocate_map(size_type __nodes_to_add,</span><br><span class="line">                                          bool __add_at_front)</span><br><span class="line">&#123;</span><br><span class="line">  size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + 1;</span><br><span class="line">  size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;</span><br><span class="line"></span><br><span class="line">  _Map_pointer __new_nstart;</span><br><span class="line">  // 如果map大小孩足够大，但是估计是左边或右边到头了，则不申请新的内存，直接copy换个位置就行。</span><br><span class="line">  if (_M_map_size &gt; 2 * __new_num_nodes) &#123;</span><br><span class="line">    __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / 2 </span><br><span class="line">                     + (__add_at_front ? __nodes_to_add : 0);</span><br><span class="line">    if (__new_nstart &lt; _M_start._M_node)</span><br><span class="line">      //一个是copy，从前往后复制</span><br><span class="line">      copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);</span><br><span class="line">    else</span><br><span class="line">      // 一个是copy_backward，从后往前复制</span><br><span class="line">      copy_backward(_M_start._M_node, _M_finish._M_node + 1, </span><br><span class="line">                    __new_nstart + __old_num_nodes);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    //否则，申请新的内存区域了</span><br><span class="line">    size_type __new_map_size = </span><br><span class="line">      _M_map_size + max(_M_map_size, __nodes_to_add) + 2;</span><br><span class="line"></span><br><span class="line">    _Map_pointer __new_map = _M_allocate_map(__new_map_size);</span><br><span class="line">    __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2</span><br><span class="line">                         + (__add_at_front ? __nodes_to_add : 0);</span><br><span class="line">    copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);</span><br><span class="line">    _M_deallocate_map(_M_map, _M_map_size);</span><br><span class="line"></span><br><span class="line">    _M_map = __new_map;</span><br><span class="line">    _M_map_size = __new_map_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _M_start._M_set_node(__new_nstart);</span><br><span class="line">  _M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);</span><br><span class="line">&#125;</span><br><span class="line">//deque比较相等，是比较内部的数据是否相等。其他容器vector,list应该也相应重载了。</span><br><span class="line">template &lt;class _Tp, class _Alloc&gt;</span><br><span class="line">inline bool operator==(const deque&lt;_Tp, _Alloc&gt;&amp; __x,</span><br><span class="line">                       const deque&lt;_Tp, _Alloc&gt;&amp; __y) &#123;</span><br><span class="line">  return __x.size() == __y.size() &amp;&amp;</span><br><span class="line">         equal(__x.begin(), __x.end(), __y.begin());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，deque的<code>erase(), insert()</code>除非在头尾，不然都算O(n)的复杂度，因为要移动其他数据。连续内存块没办法。像List的话，只要有插入或移除的对应的iterator，就是O(1)的复杂度，不过一般要得到这个iterator也得O(n)的复杂度来寻找。</p>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>stack只是普通的容器对接口做了些限制。SGI STL 以deque作为缺省情况下的stack底部结构。stack代码也真是短。接口也少。无法遍历。有一个底部容器的话，分分钟写一个stack。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#ifndef __SGI_STL_INTERNAL_STACK_H</span><br><span class="line">#define __SGI_STL_INTERNAL_STACK_H</span><br><span class="line"></span><br><span class="line">#include &lt;sequence_concepts.h&gt;</span><br><span class="line"></span><br><span class="line">__STL_BEGIN_NAMESPACE</span><br><span class="line"></span><br><span class="line">// Forward declarations of operators == and &lt;, needed for friend declaration.</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, </span><br><span class="line">          class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(deque&lt;_Tp&gt;) &gt;</span><br><span class="line">class stack;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator==(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y);</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator&lt;(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Sequence&gt;</span><br><span class="line">class stack &#123;</span><br><span class="line"></span><br><span class="line">  // requirements:</span><br><span class="line"></span><br><span class="line">  __STL_CLASS_REQUIRES(_Tp, _Assignable);</span><br><span class="line">  __STL_CLASS_REQUIRES(_Sequence, _BackInsertionSequence);</span><br><span class="line">  typedef typename _Sequence::value_type _Sequence_value_type;</span><br><span class="line">  __STL_CLASS_REQUIRES_SAME_TYPE(_Tp, _Sequence_value_type);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef __STL_MEMBER_TEMPLATES</span><br><span class="line">  template &lt;class _Tp1, class _Seq1&gt;</span><br><span class="line">  friend bool operator== (const stack&lt;_Tp1, _Seq1&gt;&amp;,</span><br><span class="line">                          const stack&lt;_Tp1, _Seq1&gt;&amp;);</span><br><span class="line">  template &lt;class _Tp1, class _Seq1&gt;</span><br><span class="line">  friend bool operator&lt; (const stack&lt;_Tp1, _Seq1&gt;&amp;,</span><br><span class="line">                         const stack&lt;_Tp1, _Seq1&gt;&amp;);</span><br><span class="line">#else /* __STL_MEMBER_TEMPLATES */</span><br><span class="line">  friend bool __STD_QUALIFIER</span><br><span class="line">  operator== __STL_NULL_TMPL_ARGS (const stack&amp;, const stack&amp;);</span><br><span class="line">  friend bool __STD_QUALIFIER</span><br><span class="line">  operator&lt; __STL_NULL_TMPL_ARGS (const stack&amp;, const stack&amp;);</span><br><span class="line">#endif /* __STL_MEMBER_TEMPLATES */</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  typedef typename _Sequence::value_type      value_type;</span><br><span class="line">  typedef typename _Sequence::size_type       size_type;</span><br><span class="line">  typedef          _Sequence                  container_type;</span><br><span class="line"></span><br><span class="line">  typedef typename _Sequence::reference       reference;</span><br><span class="line">  typedef typename _Sequence::const_reference const_reference;</span><br><span class="line">protected:</span><br><span class="line">  _Sequence c;</span><br><span class="line">public:</span><br><span class="line">  stack() : c() &#123;&#125;</span><br><span class="line">  explicit stack(const _Sequence&amp; __s) : c(__s) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  bool empty() const &#123; return c.empty(); &#125;</span><br><span class="line">  size_type size() const &#123; return c.size(); &#125;</span><br><span class="line">  reference top() &#123; return c.back(); &#125;</span><br><span class="line">  const_reference top() const &#123; return c.back(); &#125;</span><br><span class="line">  void push(const value_type&amp; __x) &#123; c.push_back(__x); &#125;</span><br><span class="line">  void pop() &#123; c.pop_back(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">//对应容器是否相等</span><br><span class="line">bool operator==(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return __x.c == __y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator&lt;(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return __x.c &lt; __y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator!=(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return !(__x == __y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator&gt;(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return __y &lt; __x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator&lt;=(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return !(__y &lt; __x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Seq&gt;</span><br><span class="line">bool operator&gt;=(const stack&lt;_Tp,_Seq&gt;&amp; __x, const stack&lt;_Tp,_Seq&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">  return !(__x &lt; __y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */</span><br><span class="line"></span><br><span class="line">__STL_END_NAMESPACE</span><br><span class="line"></span><br><span class="line">#endif /* __SGI_STL_INTERNAL_STACK_H */</span><br></pre></td></tr></table></figure>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>queue是一种先进先出（FIFO）的数据结构。从底部加入元素，从顶部取出元素。不允许遍历。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//默认用deque做底部容器</span><br><span class="line">template &lt;class _Tp, </span><br><span class="line">          class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(deque&lt;_Tp&gt;) &gt;</span><br><span class="line">class queue;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Sequence&gt;</span><br><span class="line">class queue &#123;</span><br><span class="line"></span><br><span class="line">  // requirements:</span><br><span class="line"></span><br><span class="line">  __STL_CLASS_REQUIRES(_Tp, _Assignable);</span><br><span class="line">  __STL_CLASS_REQUIRES(_Sequence, _FrontInsertionSequence);</span><br><span class="line">  __STL_CLASS_REQUIRES(_Sequence, _BackInsertionSequence);</span><br><span class="line">  typedef typename _Sequence::value_type _Sequence_value_type;</span><br><span class="line">  __STL_CLASS_REQUIRES_SAME_TYPE(_Tp, _Sequence_value_type);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef __STL_MEMBER_TEMPLATES </span><br><span class="line">  template &lt;class _Tp1, class _Seq1&gt;</span><br><span class="line">  friend bool operator== (const queue&lt;_Tp1, _Seq1&gt;&amp;,</span><br><span class="line">                          const queue&lt;_Tp1, _Seq1&gt;&amp;);</span><br><span class="line">  template &lt;class _Tp1, class _Seq1&gt;</span><br><span class="line">  friend bool operator&lt; (const queue&lt;_Tp1, _Seq1&gt;&amp;,</span><br><span class="line">                         const queue&lt;_Tp1, _Seq1&gt;&amp;);</span><br><span class="line">#else /* __STL_MEMBER_TEMPLATES */</span><br><span class="line">  //对应的容器是否相同(重载过==操作)。</span><br><span class="line">  friend bool __STD_QUALIFIER</span><br><span class="line">  operator== __STL_NULL_TMPL_ARGS (const queue&amp;, const queue&amp;);</span><br><span class="line">  friend bool __STD_QUALIFIER</span><br><span class="line">  operator&lt;  __STL_NULL_TMPL_ARGS (const queue&amp;, const queue&amp;);</span><br><span class="line">#endif /* __STL_MEMBER_TEMPLATES */</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  typedef typename _Sequence::value_type      value_type;</span><br><span class="line">  typedef typename _Sequence::size_type       size_type;</span><br><span class="line">  typedef          _Sequence                  container_type;</span><br><span class="line"></span><br><span class="line">  typedef typename _Sequence::reference       reference;</span><br><span class="line">  typedef typename _Sequence::const_reference const_reference;</span><br><span class="line">protected:</span><br><span class="line">  _Sequence c;</span><br><span class="line">public:</span><br><span class="line">  //对外只有这几个接口。front, back, push, pop</span><br><span class="line">  queue() : c() &#123;&#125;</span><br><span class="line">  explicit queue(const _Sequence&amp; __c) : c(__c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  bool empty() const &#123; return c.empty(); &#125;</span><br><span class="line">  size_type size() const &#123; return c.size(); &#125;</span><br><span class="line">  reference front() &#123; return c.front(); &#125;</span><br><span class="line">  const_reference front() const &#123; return c.front(); &#125;</span><br><span class="line">  reference back() &#123; return c.back(); &#125;</span><br><span class="line">  const_reference back() const &#123; return c.back(); &#125;</span><br><span class="line">  void push(const value_type&amp; __x) &#123; c.push_back(__x); &#125;</span><br><span class="line">  void pop() &#123; c.pop_front(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p>heap是对应的一些堆算法，不指定特殊容器。priority_queue用其进行实现和维护。底部还是需要其他容器支持。</p>
<p>警告：堆排序是不稳定的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//push_heap 对应的代码结构，从底部往上找，知道找到该点，其parent的value大于该value</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Distance, <span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__push_heap(_RandomAccessIterator __first,</span><br><span class="line">            _Distance __holeIndex, _Distance __topIndex, _Tp __value)</span><br><span class="line">&#123;</span><br><span class="line">  _Distance __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (__holeIndex &gt; __topIndex &amp;&amp; *(__first + __parent) &lt; __value) &#123;</span><br><span class="line">    <span class="comment">//将value下移至子节点</span></span><br><span class="line">    *(__first + __holeIndex) = *(__first + __parent);</span><br><span class="line">    __holeIndex = __parent;</span><br><span class="line">    __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  &#125;    </span><br><span class="line">  *(__first + __holeIndex) = __value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Distance, <span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">__push_heap_aux(_RandomAccessIterator __first,</span><br><span class="line">                _RandomAccessIterator __last, _Distance*, _Tp*)</span><br><span class="line">&#123;</span><br><span class="line">  __push_heap(__first, _Distance((__last - __first) - <span class="number">1</span>), _Distance(<span class="number">0</span>), </span><br><span class="line">              _Tp(*(__last - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line"><span class="title">push_heap</span><span class="params">(_RandomAccessIterator __first, _RandomAccessIterator __last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __push_heap_aux(__first, __last,</span><br><span class="line">                  __DISTANCE_TYPE(__first), __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pop_heap对应的代码</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Distance, <span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,</span><br><span class="line">              _Distance __len, _Tp __value)</span><br><span class="line">&#123;</span><br><span class="line">  _Distance __topIndex = __holeIndex;</span><br><span class="line">  _Distance __secondChild = <span class="number">2</span> * __holeIndex + <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//先不断往下走走走，走到叶子节点。将左右子节点较大值放入parent，然后转到该较大子节点处。循环。</span></span><br><span class="line">  <span class="keyword">while</span> (__secondChild &lt; __len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*(__first + __secondChild) &lt; *(__first + (__secondChild - <span class="number">1</span>)))</span><br><span class="line">      __secondChild--;</span><br><span class="line">    *(__first + __holeIndex) = *(__first + __secondChild);</span><br><span class="line">    __holeIndex = __secondChild;</span><br><span class="line">    __secondChild = <span class="number">2</span> * (__secondChild + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (__secondChild == __len) &#123;</span><br><span class="line">    *(__first + __holeIndex) = *(__first + (__secondChild - <span class="number">1</span>));</span><br><span class="line">    __holeIndex = __secondChild - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//然后在往上push_heap,把value插进去！目前该叶节点是没有内容的。</span></span><br><span class="line">  __push_heap(__first, __holeIndex, __topIndex, __value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Distance&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">           _RandomAccessIterator __result, _Tp __value, _Distance*)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//先把最大值移到末尾处</span></span><br><span class="line">  *__result = *__first;</span><br><span class="line">  <span class="comment">//然后调整heap，插入原本处在末尾的value</span></span><br><span class="line">  __adjust_heap(__first, _Distance(<span class="number">0</span>), _Distance(__last - __first), __value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">__pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">               _Tp*)</span><br><span class="line">&#123;</span><br><span class="line">  __pop_heap(__first, __last - <span class="number">1</span>, __last - <span class="number">1</span>, </span><br><span class="line">             _Tp(*(__last - <span class="number">1</span>)), __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(_RandomAccessIterator __first, </span><br><span class="line">                     _RandomAccessIterator __last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __pop_heap_aux(__first, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不明白为什么pop_heap的时候要先下移至叶节点，然后在进行push_heap。明明直接从上往下的时候就判断什么时候停止然后放入目标value。虽然他们的复杂度一样O(n)，但是差了一倍吧。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sort_heap首先要保证first到last的数据结构是一个合法的heap，然后不断pop最大值到尾部，实现sort</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(_RandomAccessIterator __first, _RandomAccessIterator __last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; <span class="number">1</span>)</span><br><span class="line">    pop_heap(__first, __last--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator, <span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Distance&gt;</span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__make_heap(_RandomAccessIterator __first,</span><br><span class="line">            _RandomAccessIterator __last, _Tp*, _Distance*)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__last - __first &lt; <span class="number">2</span>) return;</span><br><span class="line">  _Distance __len = __last - __first;</span><br><span class="line">  <span class="comment">//从节点的一半处开始，heap是一个完全二叉树，叶节点从左到右是满的，不会终结空一个出来。</span></span><br><span class="line">  <span class="comment">//也就是这个parent现在没有或刚有子节点（一个2或3个节点的小树）。</span></span><br><span class="line">  _Distance __parent = (__len - <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//就first是iterator类型，parent是distance类型，调整以parent为根的子树。</span></span><br><span class="line">    <span class="comment">//然后parent--,不断增大子树范围，最终实现一个heap</span></span><br><span class="line">    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)));</span><br><span class="line">    <span class="keyword">if</span> (__parent == <span class="number">0</span>) return;</span><br><span class="line">    __parent--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line"><span class="title">make_heap</span><span class="params">(_RandomAccessIterator __first, _RandomAccessIterator __last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __make_heap(__first, __last,</span><br><span class="line">              __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p>优先队列。默认的compare是最大堆。然后底层容器sort()后就是升序。</p>
<p>默认以vector为底部容器。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class _Tp, </span><br><span class="line">          class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(vector&lt;_Tp&gt;),</span><br><span class="line">          class _Compare</span><br><span class="line">            //默认的compare是less</span><br><span class="line">          __STL_DEPENDENT_DEFAULT_TMPL(less&lt;typename _Sequence::value_type&gt;) &gt;</span><br><span class="line">class priority_queue &#123;</span><br><span class="line"> </span><br><span class="line">protected:</span><br><span class="line">  //一个底部容器，一个compare</span><br><span class="line">  _Sequence c;</span><br><span class="line">  _Compare comp;</span><br><span class="line">public:</span><br><span class="line">  priority_queue() : c() &#123;&#125;</span><br><span class="line">  explicit priority_queue(const _Compare&amp; __x) :  c(), comp(__x) &#123;&#125;</span><br><span class="line">  priority_queue(const _Compare&amp; __x, const _Sequence&amp; __s) </span><br><span class="line">    : c(__s), comp(__x) </span><br><span class="line">    &#123; make_heap(c.begin(), c.end(), comp); &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;class _InputIterator&gt;</span><br><span class="line">  priority_queue(_InputIterator __first, _InputIterator __last) </span><br><span class="line">    : c(__first, __last) &#123; make_heap(c.begin(), c.end(), comp); &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;class _InputIterator&gt;</span><br><span class="line">  priority_queue(_InputIterator __first, </span><br><span class="line">                 _InputIterator __last, const _Compare&amp; __x)</span><br><span class="line">    : c(__first, __last), comp(__x) </span><br><span class="line">    &#123; make_heap(c.begin(), c.end(), comp); &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;class _InputIterator&gt;</span><br><span class="line">  priority_queue(_InputIterator __first, _InputIterator __last,</span><br><span class="line">                 const _Compare&amp; __x, const _Sequence&amp; __s)</span><br><span class="line">  : c(__s), comp(__x)</span><br><span class="line">  &#123; </span><br><span class="line">    c.insert(c.end(), __first, __last);</span><br><span class="line">    make_heap(c.begin(), c.end(), comp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool empty() const &#123; return c.empty(); &#125;</span><br><span class="line">  size_type size() const &#123; return c.size(); &#125;</span><br><span class="line">  const_reference top() const &#123; return c.front(); &#125;</span><br><span class="line">  void push(const value_type&amp; __x) &#123;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      c.push_back(__x); //先把数据push_back到尾部，再调整堆。</span><br><span class="line">      push_heap(c.begin(), c.end(), comp);</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(c.clear());</span><br><span class="line">  &#125;</span><br><span class="line">  void pop() &#123;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      pop_heap(c.begin(), c.end(), comp);//先pop_heap</span><br><span class="line">      c.pop_back();再pop出尾部数据</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(c.clear());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="slist"><a href="#slist" class="headerlink" title="slist"></a>slist</h2><p>SGI STL提供的单向链表（single linked list）。不在标准规格之内。</p>
<p>由于是单向链表，所以只能在iterator之后插入、移除才是高效的。</p>
<p>slist特别提供了<code>insert_after(),erase_after()</code>供使用。同时，只提供<code>push_front()</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _Slist_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//指针</span></span><br><span class="line">  _Slist_node_base* _M_next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> _Slist_node : <span class="keyword">public</span> _Slist_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//具体数据</span></span><br><span class="line">  _Tp _M_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _Slist_iterator_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span>               size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>            difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> forward_iterator_tag iterator_category;</span><br><span class="line"></span><br><span class="line">  _Slist_node_base* _M_node;</span><br><span class="line"></span><br><span class="line">  _Slist_iterator_base(_Slist_node_base* __x) : _M_node(__x) &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> _M_incr() &#123; _M_node = _M_node-&gt;_M_next; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(const _Slist_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</span><br><span class="line">    return _M_node == __x._M_node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(const _Slist_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</span><br><span class="line">    return _M_node != __x._M_node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Ref, <span class="keyword">class</span> _Ptr&gt;</span><br><span class="line"><span class="keyword">struct</span> _Slist_iterator : <span class="keyword">public</span> _Slist_iterator_base</span><br><span class="line">&#123;</span><br><span class="line">  _Slist_iterator(_Node* __x) : _Slist_iterator_base(__x) &#123;&#125;</span><br><span class="line">  _Slist_iterator() : _Slist_iterator_base(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  _Slist_iterator(<span class="keyword">const</span> iterator&amp; __x) : _Slist_iterator_base(__x._M_node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; return ((_Node*) _M_node)-&gt;_M_data; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; return &amp;(operator*()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">  &#123;</span><br><span class="line">    _M_incr();</span><br><span class="line">    return *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    _M_incr();</span><br><span class="line">    return __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Alloc&gt; </span><br><span class="line"><span class="keyword">struct</span> _Slist_base &#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Alloc allocator_type;</span><br><span class="line">  <span class="function">allocator_type <span class="title">get_allocator</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; return allocator_type(); &#125;</span><br><span class="line"></span><br><span class="line">  _Slist_base(<span class="keyword">const</span> allocator_type&amp;) &#123; _M_head._M_next = <span class="number">0</span>; &#125;</span><br><span class="line">  ~_Slist_base() &#123; _M_erase_after(&amp;_M_head, <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;_Slist_node&lt;_Tp&gt;, _Alloc&gt; _Alloc_type;</span><br><span class="line">  _Slist_node&lt;_Tp&gt;* _M_get_node() &#123; return _Alloc_type::allocate(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="keyword">void</span> _M_put_node(_Slist_node&lt;_Tp&gt;* __p) &#123; _Alloc_type::deallocate(__p, <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  _Slist_node_base* _M_erase_after(_Slist_node_base* __pos)</span><br><span class="line">  &#123;</span><br><span class="line">    _Slist_node&lt;_Tp&gt;* __next = (_Slist_node&lt;_Tp&gt;*) (__pos-&gt;_M_next);</span><br><span class="line">    _Slist_node_base* __next_next = __next-&gt;_M_next;</span><br><span class="line">    __pos-&gt;_M_next = __next_next;</span><br><span class="line">    destroy(&amp;__next-&gt;_M_data);</span><br><span class="line">    _M_put_node(__next);</span><br><span class="line">    return __next_next;</span><br><span class="line">  &#125;</span><br><span class="line">  _Slist_node_base* _M_erase_after(_Slist_node_base*, _Slist_node_base*);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">//空的node当head</span></span><br><span class="line">  _Slist_node_base _M_head;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class="line"><span class="keyword">class</span> slist : <span class="keyword">private</span> _Slist_base&lt;_Tp,_Alloc&gt;&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也不在意多一个prev的指针，一般还是用list的好。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/28/STL-3/" data-id="cio9k9xzj0004fynq1lwjpu6s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-STL/">C++ STL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-STL-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/19/STL-2/" class="article-date">
  <time datetime="2016-04-19T03:21:34.000Z" itemprop="datePublished">2016-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/19/STL-2/">STL源码剖析（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="4-sequence-containers"><a href="#4-sequence-containers" class="headerlink" title="4 sequence containers"></a>4 sequence containers</h1><p>常用的数据结构不外乎<code>array, list, tree, stack, queue, hash table,  set, map</code>等等， 数据结构可分为序列式(sequence)和关联式(associative)两种。</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector本身比较简单，将array抽象了一下，能够自动分配内存大小，内部存储数据的还是一个连续空间的数组类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要是如下三个属性</span></span><br><span class="line">_Tp* _M_start;</span><br><span class="line">_Tp* _M_finish;</span><br><span class="line">_Tp* _M_end_of_storage;</span><br><span class="line"><span class="comment">//然后vector相应型别定义</span></span><br></pre></td></tr></table></figure>
<p>可以随机读取、删除，<code>push_bach(),pop_back()</code>是O(1）复杂度，但是<code>insert(),earse()</code>就是O(n)的复杂度，因为要移动数组。</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>STL 的List是一个环状双向链表，且有一个空节点在链表末尾（就是List.end()指向的节点，end()一般指向最后一个节点的下一个节点），然后该空节点指向头结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list node的结构</span></span><br><span class="line"><span class="keyword">struct</span> _List_node_base &#123;</span><br><span class="line">  _List_node_base* _M_next;</span><br><span class="line">  _List_node_base* _M_prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> _List_node : <span class="keyword">public</span> _List_node_base &#123;</span><br><span class="line">  _Tp _M_data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// iterator </span></span><br><span class="line"><span class="keyword">struct</span> _List_iterator_base &#123;</span><br><span class="line">  <span class="comment">// tag是个双向的iterator</span></span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">  <span class="comment">// 主要为一个指向node的指针</span></span><br><span class="line">  _List_node_base* _M_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>List因为是链表结构，所以每次申请空间可以只申请一个，<code>push_back(), push_front(), insert(iterator，value)</code>都是O(1)的复杂度。</p>
<p><code>unique()</code>只删除连续出现的相同的元素，因在<code>sort()</code>之后使用，<code>remove(value)</code>删除所有相同元素，而不是第一个。</p>
<p>list的<code>sort()</code>采用自定义的<code>sort()</code>函数，STL源码剖析中说是采用的<del>~quick sort</del>~，其实应该是merge sort，看了很久才理解。<a href="http://blog.csdn.net/lijun5635/article/details/23963707" target="_blank" rel="external">该处</a>举了个例子，讲的比较清楚。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;_Tp, _Alloc&gt;::sort()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Do nothing if the list has length 0 or 1.</span></span><br><span class="line">  <span class="keyword">if</span> (_M_node-&gt;_M_next != _M_node &amp;&amp; _M_node-&gt;_M_next-&gt;_M_next != _M_node) &#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;_Tp, _Alloc&gt; __carry;</span><br><span class="line">    <span class="comment">//用来存放以排好序的List数组</span></span><br><span class="line">    <span class="built_in">list</span>&lt;_Tp, _Alloc&gt; __counter[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> __fill = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!empty()) &#123;</span><br><span class="line">      <span class="comment">/*先1、2排序，放入counter[1],然后3，4排序，再跟counter[1]进行merge，放入counter[2]，完成1、2、3、4排序。然后在5、6、7、8排序，再跟contour[2]merge等等.所以counter[64]可以最多2^64个数据.*/</span></span><br><span class="line">      __carry.splice(__carry.begin(), *<span class="keyword">this</span>, begin());</span><br><span class="line">      <span class="keyword">int</span> __i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(__i &lt; __fill &amp;&amp; !__counter[__i].empty()) &#123;</span><br><span class="line">        __counter[__i].merge(__carry);</span><br><span class="line">        __carry.swap(__counter[__i++]);</span><br><span class="line">      &#125;</span><br><span class="line">      __carry.swap(__counter[__i]);         </span><br><span class="line">      <span class="keyword">if</span> (__i == __fill) ++__fill;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> __i = <span class="number">1</span>; __i &lt; __fill; ++__i)</span><br><span class="line">      __counter[__i].merge(__counter[__i<span class="number">-1</span>]);</span><br><span class="line">    swap(__counter[__fill<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/19/STL-2/" data-id="cio9k9xzg0003fynq2yf7nbd3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-STL/">C++ STL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-STL-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/15/STL-1/" class="article-date">
  <time datetime="2016-04-15T12:57:49.000Z" itemprop="datePublished">2016-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/15/STL-1/">STL源码剖析（1）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-9-一些C-语法"><a href="#1-9-一些C-语法" class="headerlink" title="1.9 一些C++语法"></a>1.9 一些C++语法</h2><h3 id="1-9-2-临时对象的产生于运用"><a href="#1-9-2-临时对象的产生于运用" class="headerlink" title="1.9.2 临时对象的产生于运用"></a>1.9.2 临时对象的产生于运用</h3><p>通过临时对象，简化程序。在类型名称之后直接加小括号，并制定初值，e.g.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shape(<span class="number">3</span>,<span class="number">5</span>), <span class="keyword">int</span>(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p>STL 最常将此技巧应用于仿函数（Functor)于算法的搭配上。</p>
<p>PS：Functor 还没细看。</p>
<h3 id="1-9-3-静态常量证书成员在class内部直接初始化"><a href="#1-9-3-静态常量证书成员在class内部直接初始化" class="headerlink" title="1.9.3 静态常量证书成员在class内部直接初始化"></a>1.9.3 静态常量证书成员在class内部直接初始化</h3><p>const static <em>integral</em> data member </p>
<p><em>integral</em> 泛指所有整数型别：int, long, char 等</p>
<h2 id="2-allocator"><a href="#2-allocator" class="headerlink" title="2 allocator"></a>2 allocator</h2><ul>
<li><p>设置sub-allocation, 两层结构，分别对应大内存和小内存的申请空间</p>
</li>
<li><p>小内存设置free lists。结构为union,节省内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> obj &#123;</span><br><span class="line">  <span class="keyword">union</span> obj * free_list_link;</span><br><span class="line">  <span class="keyword">char</span> client_data[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>并设置区块的对齐（<code>round_up(size_t bytes)</code>），比如都是8的倍数，（如30bytes的，自动调整为32bytes），标准化内存申请，可重复性高。</p>
</li>
<li><p>free lists某个块区的list用完了，通过<code>chunk_alloc()</code>,首先向内存池(memory pool)申请，实在没有了，可以用free lists中更大的块区，分配给它。</p>
</li>
<li><p><code>ctor(), dtor(), copy(), fill(), fill_n()</code>等，都可以根据情况，选择更高效的填充方法。看它的<code>is_POD_type</code>等是否是trivial的，第三章有具体讲。</p>
</li>
<li><p>通过traits（只要还是重载，参数不同，还可以实现特化版本）对应不同的具体实现。</p>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> T&gt;</span><br><span class="line">  <span class="function">Function <span class="title">find</span><span class="params">(InputIterator first, InputIterator last, <span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first != last &amp;&amp; *first != value) ++first;</span><br><span class="line">  return first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> Function&gt;</span><br><span class="line">  <span class="function">Function <span class="title">for_each</span><span class="params">(InputIterator first, InputIterator last, Function f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">    f(*first);</span><br><span class="line">  return f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数写的挺帅的。</p>
<h2 id="3-iterators-and-traits"><a href="#3-iterators-and-traits" class="headerlink" title="3 iterators and traits"></a>3 iterators and traits</h2><p>STL中心思想：将数据容器（containers）和算法（algorithms）分开，彼此独立设计，最后再将他们撮合在一起。（适配器？）</p>
<p>iterator 可看做是一种smart pointer。基本上要提供<code>operator*, operator-&gt;,operator++,operator--</code>等。</p>
<h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><p>auto_ptr是一个用来包装原生指针的对象，析构函数会自动delete掉内存。</p>
<p>在<code>&lt;memory&gt;</code>内</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class _Tp&gt; class auto_ptr &#123;</span><br><span class="line">private:</span><br><span class="line">  _Tp* _M_ptr;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  typedef _Tp element_type;</span><br><span class="line">//无法隐式转换，无法auto_ptr p1 = p2；</span><br><span class="line">  explicit auto_ptr(_Tp* __p = 0) __STL_NOTHROW : _M_ptr(__p) &#123;&#125;</span><br><span class="line">  auto_ptr(auto_ptr&amp; __a) __STL_NOTHROW : _M_ptr(__a.release()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">#ifdef __STL_MEMBER_TEMPLATES</span><br><span class="line">  template &lt;class _Tp1&gt; auto_ptr(auto_ptr&lt;_Tp1&gt;&amp; __a) __STL_NOTHROW</span><br><span class="line">    : _M_ptr(__a.release()) &#123;&#125;</span><br><span class="line">#endif /* __STL_MEMBER_TEMPLATES */</span><br><span class="line">//在赋值时，原有指针释放。</span><br><span class="line">  auto_ptr&amp; operator=(auto_ptr&amp; __a) __STL_NOTHROW &#123;</span><br><span class="line">    if (&amp;__a != this) &#123;</span><br><span class="line">      delete _M_ptr;</span><br><span class="line">      _M_ptr = __a.release();</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">#ifdef __STL_MEMBER_TEMPLATES</span><br><span class="line">  template &lt;class _Tp1&gt;</span><br><span class="line">  auto_ptr&amp; operator=(auto_ptr&lt;_Tp1&gt;&amp; __a) __STL_NOTHROW &#123;</span><br><span class="line">    if (__a.get() != this-&gt;get()) &#123;</span><br><span class="line">      delete _M_ptr;</span><br><span class="line">      _M_ptr = __a.release();</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line">#endif /* __STL_MEMBER_TEMPLATES */</span><br><span class="line"></span><br><span class="line">  // Note: The C++ standard says there is supposed to be an empty throw</span><br><span class="line">  // specification here, but omitting it is standard conforming.  Its </span><br><span class="line">  // presence can be detected only if _Tp::~_Tp() throws, but (17.4.3.6/2)</span><br><span class="line">  // this is prohibited.</span><br><span class="line">  ~auto_ptr() &#123; delete _M_ptr; &#125;</span><br><span class="line"></span><br><span class="line">  _Tp&amp; operator*() const __STL_NOTHROW &#123;</span><br><span class="line">    return *_M_ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  _Tp* operator-&gt;() const __STL_NOTHROW &#123;</span><br><span class="line">    return _M_ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  _Tp* get() const __STL_NOTHROW &#123;</span><br><span class="line">    return _M_ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  //释放该所有权，将指针返回</span><br><span class="line">  _Tp* release() __STL_NOTHROW &#123;</span><br><span class="line">    _Tp* __tmp = _M_ptr;</span><br><span class="line">    _M_ptr = 0;</span><br><span class="line">    return __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  //重新赋值，原有对象释放</span><br><span class="line">  void reset(_Tp* __p = 0) __STL_NOTHROW &#123;</span><br><span class="line">    if (__p != _M_ptr) &#123;</span><br><span class="line">      delete _M_ptr;</span><br><span class="line">      _M_ptr = __p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // According to the C++ standard, these conversions are required.  Most</span><br><span class="line">  // present-day compilers, however, do not enforce that requirement---and, </span><br><span class="line">  // in fact, most present-day compilers do not support the language </span><br><span class="line">  // features that these conversions rely on.</span><br><span class="line">  </span><br><span class="line">#if defined(__SGI_STL_USE_AUTO_PTR_CONVERSIONS) &amp;&amp; \</span><br><span class="line">    defined(__STL_MEMBER_TEMPLATES)</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  auto_ptr(auto_ptr_ref&lt;_Tp&gt; __ref) __STL_NOTHROW</span><br><span class="line">    : _M_ptr(__ref._M_ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  auto_ptr&amp; operator=(auto_ptr_ref&lt;_Tp&gt; __ref) __STL_NOTHROW &#123;</span><br><span class="line">    if (__ref._M_ptr != this-&gt;get()) &#123;</span><br><span class="line">      delete _M_ptr;</span><br><span class="line">      _M_ptr = __ref._M_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;class _Tp1&gt; operator auto_ptr_ref&lt;_Tp1&gt;() __STL_NOTHROW </span><br><span class="line">    &#123; return auto_ptr_ref&lt;_Tp1&gt;(this-&gt;release()); &#125;</span><br><span class="line">  template &lt;class _Tp1&gt; operator auto_ptr&lt;_Tp1&gt;() __STL_NOTHROW</span><br><span class="line">    &#123; return auto_ptr&lt;_Tp1&gt;(this-&gt;release()); &#125;</span><br><span class="line"></span><br><span class="line">#endif /* auto ptr conversions &amp;&amp; member templates */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>auto_ptr指向的内存是独占性的，当它赋值给另一个auto_ptr时，其自身就不再指向该内存区域了，所以最好只在初始化阶段赋值，使用阶段并不将其赋给其他对象。</p>
<blockquote>
<p>auto_ptr适合用来管理生命周期比较短或者不会被远距离传递的动态对象，使用auto_ptr来管理动态分配对象，最好是局限于某个函数内部或者是某个类的内部。也就是说，动态对象的产生，使用和销毁的全过程是处于一个小的受控的范围，而不会在其中加入一些适应未来时态的扩展。</p>
</blockquote>
<p>STL 源码剖析中，特意说明了auto_ptr的存在，但是没讲清楚其独占的特性，简化版中<code>release()，reset()</code>的实现没写，感觉比较坑。</p>
<h3 id="3-4-Traits"><a href="#3-4-Traits" class="headerlink" title="3.4 Traits"></a>3.4 Traits</h3><p>首先，通过参数推导机制，我们可以得到迭代器及其指向数据（其指向数据类型需要在子函数中用模板得到）的类型，但是（所以）无法用于函数的返回值。</p>
<p>以vector为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in &lt;stl_vector.h&gt;</span></span><br><span class="line">  <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line"><span class="comment">// iterator 就是value_type*的，</span></span><br><span class="line">  <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base::allocator_type allocator_type;</span><br><span class="line"><span class="comment">//使用时将iterator赋给相应的iterator类，来完成具体工作</span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator;</span><br></pre></td></tr></table></figure>
<p>其中定义了其数据的各种类型,内部没有定义iterator catagoly，只是需要时直接使用，在Iterator中有。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _InputIterator&gt;</span><br><span class="line"><span class="keyword">void</span> _M_range_insert(iterator __pos,</span><br><span class="line">                     _InputIterator __first, _InputIterator __last,</span><br><span class="line">                     input_iterator_tag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _ForwardIterator&gt;</span><br><span class="line"><span class="keyword">void</span> _M_range_insert(iterator __pos,</span><br><span class="line">                     _ForwardIterator __first, _ForwardIterator __last,</span><br><span class="line">                     forward_iterator_tag);</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//in &lt;stl_iterator.h&gt;</span><br><span class="line">template &lt;class _Container&gt;</span><br><span class="line">//还有 front_insert_iterator, intert_iterator等好多。</span><br><span class="line">class back_insert_iterator &#123;</span><br><span class="line">protected:</span><br><span class="line">  _Container* container;</span><br><span class="line">public:</span><br><span class="line">  typedef _Container          container_type;</span><br><span class="line">  typedef output_iterator_tag iterator_category;</span><br><span class="line">  typedef void                value_type;</span><br><span class="line">  typedef void                difference_type;</span><br><span class="line">  typedef void                pointer;</span><br><span class="line">  typedef void                reference;</span><br><span class="line"></span><br><span class="line">  explicit back_insert_iterator(_Container&amp; __x) : container(&amp;__x) &#123;&#125;</span><br><span class="line">  back_insert_iterator&lt;_Container&gt;&amp;</span><br><span class="line">  operator=(const typename _Container::value_type&amp; __value) &#123; </span><br><span class="line">    container-&gt;push_back(__value);</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line">  back_insert_iterator&lt;_Container&gt;&amp; operator*() &#123; return *this; &#125;</span><br><span class="line">  back_insert_iterator&lt;_Container&gt;&amp; operator++() &#123; return *this; &#125;</span><br><span class="line">  back_insert_iterator&lt;_Container&gt;&amp; operator++(int) &#123; return *this; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class _Iterator&gt;</span><br><span class="line">class reverse_iterator </span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">  _Iterator current;</span><br><span class="line">public:</span><br><span class="line">  typedef typename iterator_traits&lt;_Iterator&gt;::iterator_category</span><br><span class="line">          iterator_category;</span><br><span class="line">  typedef typename iterator_traits&lt;_Iterator&gt;::value_type</span><br><span class="line">          value_type;</span><br><span class="line">  typedef typename iterator_traits&lt;_Iterator&gt;::difference_type</span><br><span class="line">          difference_type;</span><br><span class="line">  typedef typename iterator_traits&lt;_Iterator&gt;::pointer</span><br><span class="line">          pointer;</span><br><span class="line">  typedef typename iterator_traits&lt;_Iterator&gt;::reference</span><br><span class="line">          reference;</span><br><span class="line"></span><br><span class="line">  typedef _Iterator iterator_type;</span><br><span class="line">  typedef reverse_iterator&lt;_Iterator&gt; _Self;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in &lt;stl_iterator_base.h&gt;</span></span><br><span class="line"><span class="keyword">struct</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> output_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> forward_iterator_tag : <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> bidirectional_iterator_tag : <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> random_access_iterator_tag : <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Distance&gt; <span class="keyword">struct</span> input_iterator &#123;</span><br><span class="line">  <span class="keyword">typedef</span> input_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp                value_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Distance          difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp*               pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp&amp;               reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Iterator&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator_traits &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::iterator_category iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::value_type        value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::difference_type   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::pointer           pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::reference         reference;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>最基本的iterator直接使用value type*完成，比如reverse_iterator就使用对应的类简化。</p>
<h3 id="type-traits"><a href="#type-traits" class="headerlink" title="__type_traits"></a>__type_traits</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;type_traits.h&gt;</span></span><br><span class="line"><span class="keyword">struct</span> __true_type &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __false_type &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> __type_traits &#123; </span><br><span class="line">   <span class="keyword">typedef</span> __true_type     this_dummy_member_must_be_first;</span><br><span class="line">                   <span class="comment">/* Do not remove this member. It informs a compiler which</span><br><span class="line">                      automatically specializes __type_traits that this</span><br><span class="line">                      __type_traits template is special. It just makes sure that</span><br><span class="line">                      things work if an implementation is using a template</span><br><span class="line">                      called __type_traits for something unrelated. */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* The following restrictions should be observed for the sake of</span><br><span class="line">      compilers which automatically produce type specific specializations </span><br><span class="line">      of this class:</span><br><span class="line">          - You may reorder the members below if you wish</span><br><span class="line">          - You may remove any of the members below if you wish</span><br><span class="line">          - You must not rename members without making the corresponding</span><br><span class="line">            name change in the compiler</span><br><span class="line">          - Members you add will be treated like regular members unless</span><br><span class="line">            you add the appropriate support in the compiler. */</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//对char, bool, int等很多做了特化处理。</span></span><br></pre></td></tr></table></figure>
<p>iterator_traits负责萃取迭代器的特性，__type_traits负责萃取类型的特性（<code>ctor(), copy(), assignment()</code>的时候用到，提高内存复制、赋值的效率。</p>
<p>PS：感觉STL代码写的挺好的，并不是很难看懂。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/15/STL-1/" data-id="cio9k9xyv0000fynq98p3dus4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-STL/">C++ STL</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-STL/">C++ STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图-路径压缩/">图 路径压缩</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-STL/" style="font-size: 20px;">C++ STL</a> <a href="/tags/图-路径压缩/" style="font-size: 10px;">图 路径压缩</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/05/16/STL-4/">STL源码剖析（4）</a>
          </li>
        
          <li>
            <a href="/2016/05/02/union-find/">并查集union-find</a>
          </li>
        
          <li>
            <a href="/2016/04/28/STL-3/">STL源码剖析（3）</a>
          </li>
        
          <li>
            <a href="/2016/04/19/STL-2/">STL源码剖析（2）</a>
          </li>
        
          <li>
            <a href="/2016/04/15/STL-1/">STL源码剖析（1）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 ding4it<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>